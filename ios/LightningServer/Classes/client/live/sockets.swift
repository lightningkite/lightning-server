// Package: com.lightningkite.lightningdb.live
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import RxSwift
import RxSwiftPlus
import Foundation

public var sharedSocketShouldBeActive: Observable<Bool> = Observable.just(true)
private var retryTime = 1000
private var lastRetry = 0

public var _overrideWebSocketProvider: ((String) -> Observable<WebSocketInterface>)? = nil
private var sharedSocketCache = Dictionary<String, Observable<WebSocketInterface>>()
public func sharedSocket(url: String) -> Observable<WebSocketInterface> {
    return sharedSocketCache.getOrPut(key: url) { () -> Observable<WebSocketInterface> in sharedSocketShouldBeActive
            .distinctUntilChanged()
            .switchMap { (it) -> Observable<WebSocketInterface> in
            let shortUrl = url.substringBefore(delimiter: "?")
            return run { () -> Observable<WebSocketInterface> in
                if (!it) { return (Observable.never() as Observable<WebSocketInterface>) } else {
                    print("Creating socket to \(String(kotlin: url))")
                    return (_overrideWebSocketProvider?(url) ?? HttpClient.INSTANCE.webSocket(url: url))
                        .switchMap { (it) -> Observable<WebSocketInterface> in
                        lastRetry = Int(Date().timeIntervalSince1970 * 1000.0)
                        //                            println("Connection to $shortUrl established, starting pings")
                        // Only have this observable until it fails
                        
                        let pingMessages: Observable<WebSocketInterface> = Observable<Int>.interval(RxTimeInterval.milliseconds(Int(30000)), scheduler: HttpClient.INSTANCE.responseScheduler!)
                            .map { (_) -> Void in it.write.onNext(WebSocketFrame(text: " ")) }.switchMap { (it) -> Observable<WebSocketInterface> in Observable.never() }
                        
                        let timeoutAfterSeconds: Observable<WebSocketInterface> = it.read
                            .doOnNext { (it) -> Void in if Int(Date().timeIntervalSince1970 * 1000.0) > lastRetry + 60000 {
                            retryTime = 1000
                        } }
                            .timeout(.milliseconds(40000), scheduler: MainScheduler.instance)
                            .switchMap { (it) -> Observable<WebSocketInterface> in Observable.never() }
                        
                        return Observable.merge(Observable.just(it), pingMessages, timeoutAfterSeconds)
                    }
                        .doOnError { (it) -> Void in print("Socket to \(String(kotlin: shortUrl)) FAILED with \(it)") }
                        .retry(when:  { (it) -> Observable<Error> in
                        let temp = retryTime
                        retryTime = temp * 2
                        return it.delay(.milliseconds(temp), scheduler: MainScheduler.instance)
                    })
                        .doOnDispose { () -> Void in print("Disconnecting socket to \(String(kotlin: shortUrl))") }
                }
            }
        }
            .replay(1)
        .refCount() }
}

public final class WebSocketIsh<IN : Any, OUT> {
    public var messages: Observable<IN>
    public var send: (OUT) -> Void
    public init(messages: Observable<IN>, send: @escaping (OUT) -> Void) {
        self.messages = messages
        self.send = send
        //Necessary properties should be initialized now
    }
}

public func multiplexedSocket<IN : Codable & Hashable, OUT : Codable & Hashable>(url: String, path: String, queryParams: Dictionary<String, Array<String>> = dictionaryOf()) -> Observable<WebSocketIsh<IN, OUT>> {
    return multiplexedSocket(url: url, path: path, queryParams: queryParams, inType: IN.self, outType: OUT.self);
}

public func multiplexedSocket<IN : Codable & Hashable, OUT : Codable & Hashable>(url: String, path: String, queryParams: Dictionary<String, Array<String>> = dictionaryOf(), inType: IN.Type, outType: OUT.Type) -> Observable<WebSocketIsh<IN, OUT>> {
    return multiplexedSocketRaw(url: url, path: path, queryParams: queryParams)
        .map { (it) -> WebSocketIsh<IN, OUT> in WebSocketIsh(messages: it.messages.compactMap({ (it) -> IN? in it.fromJsonString(serializer: IN.self) }), send: { (m) -> Void in it.send(m.toJsonString()) }) };
}

public func multiplexedSocketRaw(url: String, path: String, queryParams: Dictionary<String, Array<String>> = dictionaryOf()) -> Observable<WebSocketIsh<String, String>> {
    let shortUrl = url.substringBefore(delimiter: "?")
    let channel = String(kotlin: UUID.randomUUID())
    return sharedSocket(url: url)
        .switchMap { (sharedSocket) -> Observable<WebSocketIsh<String, String>> in
        //            println("Setting up channel $channel to $shortUrl with $path")
        let multiplexedIn = sharedSocket.read.compactMap({ (it) -> MultiplexMessage? in
            guard let text = it.text else { return nil }
            if text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty { return nil }
            return (text.fromJsonString() as MultiplexMessage?)
        }).filter { (it) -> Bool in it.channel == channel }
        var current: PublishSubject<String> = PublishSubject()
        return multiplexedIn
            .compactMap({ (message) -> WebSocketIsh<String, String>? in run { () -> WebSocketIsh<String, String>? in
            if message.start {
                //                            println("Channel ${message.channel} established with $sharedSocket")
                return (WebSocketIsh(messages: current as Observable<String>, send: { (message) -> Void in sharedSocket.write.onNext(WebSocketFrame(text: MultiplexMessage(channel: channel, data: message).toJsonString())) } as (String) -> Void) as WebSocketIsh<String, String>)
            } else if message.data != nil {
                //                            println("Got ${message.data} to ${message.channel}")
                current.onNext(message.data!)
                return nil
            } else if message.end {
                //                            println("Channel ${message.channel} terminated")
                current = PublishSubject()
                sharedSocket.write.onNext(WebSocketFrame(text: MultiplexMessage(channel: channel, path: path, queryParams: queryParams, start: true).toJsonString()))
                return nil
            } else  {
                return nil
            }
        } })
            .doOnSubscribe { (_) -> Void in sharedSocket.write.onNext(WebSocketFrame(text: MultiplexMessage(channel: channel, path: path, queryParams: queryParams, start: true).toJsonString())) }
            .doOnDispose { () -> Void in sharedSocket.write.onNext(WebSocketFrame(text: MultiplexMessage(channel: channel, path: path, end: true).toJsonString())) }
            .retry(when:  { (it) -> Observable<Error> in
            let temp = retryTime
            retryTime = temp * 2
            return it.delay(.milliseconds(temp), scheduler: MainScheduler.instance)
        })
    }
}

