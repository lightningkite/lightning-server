// Package: com.lightningkite.lightningdb.live
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import RxSwift
import RxSwiftPlus
import Foundation

public var _overrideWebSocketProvider: ((String) -> Observable<WebSocketInterface>)? = nil
private var sharedSocketCache = Dictionary<String, Observable<WebSocketInterface>>()
public func sharedSocket(url: String) -> Observable<WebSocketInterface> {
    return sharedSocketCache.getOrPut(key: url) { () -> Observable<WebSocketInterface> in
        let shortUrl = url.substringBefore(delimiter: "?")
        print("Creating socket to \(String(kotlin: url))")
        return (_overrideWebSocketProvider?(url) ?? HttpClient.INSTANCE.webSocket(url: url))
            .switchMap { (it) -> Observable<WebSocketInterface> in
            print("Connection to \(String(kotlin: shortUrl)) established, starting pings")
            // Only have this observable until it fails
            
            let pingMessages: Observable<WebSocketInterface> = Observable<Int>.interval(RxTimeInterval.milliseconds(Int(30000)), scheduler: HttpClient.INSTANCE.responseScheduler!).map { (_) -> Void in
                print("Sending ping to \(String(kotlin: url))")
                return it.write.onNext(WebSocketFrame(text: " "))
            }.switchMap { (it) -> Observable<WebSocketInterface> in Observable.never() }
            
            let timeoutAfterSeconds: Observable<WebSocketInterface> = it.read
                .doOnNext { (it) -> Void in print("Got message from \(String(kotlin: shortUrl)): \(it)") }
                .timeout(.milliseconds(60000), scheduler: MainScheduler.instance)
                .switchMap { (it) -> Observable<WebSocketInterface> in Observable.never() }
            
            return Observable.merge(Observable.just(it), pingMessages, timeoutAfterSeconds)
        }
            .doOnError { (it) -> Void in print("Socket to \(String(kotlin: shortUrl)) FAILED with \(it)") }
            .doOnComplete { () -> Void in
            print("Disconnecting socket to \(String(kotlin: shortUrl))")
            sharedSocketCache.removeValue(forKey: url)
        }
            .replay(1)
            .refCount()
    }
}

public final class WebSocketIsh<IN : Any, OUT> {
    public var messages: Observable<IN>
    public var send: (OUT) -> Void
    public init(messages: Observable<IN>, send: @escaping (OUT) -> Void) {
        self.messages = messages
        self.send = send
        //Necessary properties should be initialized now
    }
}

public func multiplexedSocket<IN : Codable & Hashable, OUT : Codable & Hashable>(url: String, path: String, queryParams: Dictionary<String, Array<String>> = dictionaryOf()) -> Observable<WebSocketIsh<IN, OUT>> {
    return multiplexedSocket(url: url, path: path, queryParams: queryParams, inType: IN.self, outType: OUT.self);
}

public func multiplexedSocket<IN : Codable & Hashable, OUT : Codable & Hashable>(url: String, path: String, queryParams: Dictionary<String, Array<String>> = dictionaryOf(), inType: IN.Type, outType: OUT.Type) -> Observable<WebSocketIsh<IN, OUT>> {
    return multiplexedSocketRaw(url: url, path: path, queryParams: queryParams)
        .map { (it) -> WebSocketIsh<IN, OUT> in WebSocketIsh(messages: it.messages.compactMap({ (it) -> IN? in it.fromJsonString(serializer: IN.self) }), send: { (m) -> Void in it.send(m.toJsonString()) }) };
}
public func multiplexedSocketRaw(url: String, path: String, queryParams: Dictionary<String, Array<String>> = dictionaryOf()) -> Observable<WebSocketIsh<String, String>> {
    let shortUrl = url.substringBefore(delimiter: "?")
    let channel = String(kotlin: UUID.randomUUID())
    var lastSocket: WebSocketInterface? = nil
    return sharedSocket(url: url)
        .flatMap({ (it) -> Single<WebSocketIsh<String, String>> in
        print("Setting up socket to \(String(kotlin: shortUrl)) with \(String(kotlin: path))")
        lastSocket = it
        let multiplexedIn = it.read.compactMap({ (it) -> MultiplexMessage? in
            guard let text = it.text else { return nil }
            if text.isEmpty { return nil }
            return (text.fromJsonString() as MultiplexMessage?)
        })
        return multiplexedIn
            .filter { (it) -> Bool in it.channel == channel && it.start }
            .firstOrError()
            .map { (_) -> WebSocketIsh<String, String> in
            print("Connected to channel \(String(kotlin: channel))")
            return (WebSocketIsh(messages: multiplexedIn.compactMap({ (it) -> String? in it.channel == channel ? it.data : nil }) as Observable<String>, send: { (message) -> Void in
                print("Sending \(String(kotlin: message)) to \(it)")
                it.write.onNext(WebSocketFrame(text: MultiplexMessage(channel: channel, data: message).toJsonString()))
            } as (String) -> Void) as WebSocketIsh<String, String>)
        }
            .doOnSubscribe { (_) -> Void in it.write.onNext(WebSocketFrame(text: MultiplexMessage(channel: channel, path: path, queryParams: queryParams, start: true).toJsonString())) }
    })
        .doOnDispose { () -> Void in
        print("Disconnecting channel on socket to \(String(kotlin: shortUrl)) with \(String(kotlin: path))")
        lastSocket?.write.onNext(WebSocketFrame(text: MultiplexMessage(channel: channel, path: path, end: true).toJsonString()))
    }
}

