// Package: com.lightningkite.lightningdb.live
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import RxSwift
import RxSwiftPlus
import Foundation

public final class LiveReadModelApi<Model : HasId> : ReadModelApi<Model> {
    public var url: String
    public var serializer: Model.Type
    public init(url: String, token: String, headers: Dictionary<String, String> = dictionaryOf(), serializer: Model.Type) {
        self.url = url
        self.serializer = serializer
        self.authHeaders = headers.plus(dictionaryOf(Pair("Authorization", "Bearer \(String(kotlin: token))")))
        super.init()
        //Necessary properties should be initialized now
    }
    
    
    
    
    
    private let authHeaders: Dictionary<String, String>
    
    override public func list(_ query: Query<Model>) -> Single<Array<Model>> {
        return HttpClient.INSTANCE.call(url: "\(String(kotlin: self.url))/query", method: HttpClient.INSTANCE.POST, headers: self.authHeaders, body: query.toJsonRequestBody()).readJson(serializer: Array<Model>.self);
    }
    
    
    override public func get(id: UUIDFor<Model>) -> Single<Model> {
        return HttpClient.INSTANCE.call(url: "\(String(kotlin: self.url))/\(id)", method: HttpClient.INSTANCE.GET, headers: self.authHeaders).readJson(serializer: Model.self);
    }
    
}


public final class LiveReadModelApiCompanion {
    public init() {
        //Necessary properties should be initialized now
    }
    public static let INSTANCE = LiveReadModelApiCompanion()
    
    public func create<Model : HasId>(root: String, path: String, token: String, headers: Dictionary<String, String> = dictionaryOf()) -> LiveReadModelApi<Model> {
        return LiveReadModelApi<Model>(url: "\(String(kotlin: root))\(String(kotlin: path))", token: token, headers: headers, serializer: Model.self);
    }
}
