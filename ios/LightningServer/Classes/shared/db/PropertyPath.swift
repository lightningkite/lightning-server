// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public class PropertyPathPartial<K> {
    public init() {
        //Necessary properties should be initialized now
    }
    
    open func getAny(key: K) -> Any? { TODO() }
    open func setAny(key: K, any: Any?) -> K { TODO() }
    public var properties: Array<PropertyIterableProperty<Any?, Any?>> { get { TODO() } }
}

public class PropertyPath<K, V> : PropertyPathPartial<K> {
    override public init() {
        super.init()
        //Necessary properties should be initialized now
    }
    
    open func get(key: K) -> V { TODO() }
    open func set(key: K, value: V) -> K { TODO() }
    override open func getAny(key: K) -> V {
        return self.get(key: key);
    }
    override open func setAny(key: K, any: Any?) -> K {
        return self.set(key: key, value: any as! V);
    }
    
    open func mapCondition(_ condition: Condition<V>) -> Condition<K> { TODO() }
    open func mapModification(_ modification: Modification<V>) -> Modification<K> { TODO() }
}

public final class PropertyPathSelf<K> : PropertyPath<K, K> {
    override public init() {
        super.init()
        //Necessary properties should be initialized now
    }
    
    override public func get(key: K) -> K {
        return key;
    }
    override public func set(key: K, value: K) -> K {
        return value;
    }
    override public func toString() -> String {
        return "this";
    }
    override public func hashCode() -> Int {
        return 0;
    }
    override public func equals(other: Any) -> Bool {
        return other is PropertyPathSelf<Any?>;
    }
    override public var properties: Array<PropertyIterableProperty<Any?, Any?>> {
        get { return [] }
    }
    override public func mapCondition(_ condition: Condition<K>) -> Condition<K> {
        return condition;
    }
    override public func mapModification(_ modification: Modification<K>) -> Modification<K> {
        return modification;
    }
}
public final class PropertyPathAccess<K, M, V> : PropertyPath<K, V>, CustomStringConvertible {
    public var first: PropertyPath<K, M>
    public var second: PropertyIterableProperty<M, V>
    public init(first: PropertyPath<K, M>, second: PropertyIterableProperty<M, V>) {
        self.first = first
        self.second = second
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(first)
        hasher.combine(second)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? PropertyPathAccess else { return false }
        return self.first == other.first && self.second == other.second
    }
    public var description: String { return "PropertyPathAccess(first=\(String(kotlin: self.first)), second=\(String(kotlin: self.second)))" }
    public func copy(first: PropertyPath<K, M>? = nil, second: PropertyIterableProperty<M, V>? = nil) -> PropertyPathAccess<K, M, V> { return PropertyPathAccess(first: first ?? self.first, second: second ?? self.second) }
    
    override public func get(key: K) -> V {
        return ({ (it) -> V in self.second.get(it) })(self.first.get(key: key));
    }
    override public func set(key: K, value: V) -> K {
        return self.first.set(key: key, value: self.second.set(self.first.get(key: key), value));
    }
    override public func toString() -> String {
        return self.first is PropertyPathSelf<Any?> ? self.second.name : "\(self.first).\(String(kotlin: self.second.name))";
    }
    override public var properties: Array<PropertyIterableProperty<Any?, Any?>> {
        get { return self.first.properties + [self.second] }
    }
    override public func mapCondition(_ condition: Condition<V>) -> Condition<K> {
        return self.first.mapCondition(ConditionOnField(key: self.second, condition: condition));
    }
    override public func mapModification(_ modification: Modification<V>) -> Modification<K> {
        return self.first.mapModification(ModificationOnField(key: self.second, modification: modification));
    }
}
public final class PropertyPathSafeAccess<K, M : Any, V> : PropertyPath<K, V?>, CustomStringConvertible {
    public var first: PropertyPath<K, M?>
    public var second: PropertyIterableProperty<M, V>
    public init(first: PropertyPath<K, M?>, second: PropertyIterableProperty<M, V>) {
        self.first = first
        self.second = second
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(first)
        hasher.combine(second)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? PropertyPathSafeAccess else { return false }
        return self.first == other.first && self.second == other.second
    }
    public var description: String { return "PropertyPathSafeAccess(first=\(String(kotlin: self.first)), second=\(String(kotlin: self.second)))" }
    public func copy(first: PropertyPath<K, M?>? = nil, second: PropertyIterableProperty<M, V>? = nil) -> PropertyPathSafeAccess<K, M, V> { return PropertyPathSafeAccess(first: first ?? self.first, second: second ?? self.second) }
    
    override public func get(key: K) -> V? {
        return (self.first.get(key: key)).flatMap { temp200 in ({ (it) -> V in self.second.get(it) })(temp200) };
    }
    override public func set(key: K, value: V?) -> K {
        return (self.first.get(key: key)).map { (it) in
            return
            self.first.set(key: key, value: self.second.set(it, value as! V))
        } ?? key;
    }
    override public func toString() -> String {
        return "\(self.first)?.\(String(kotlin: self.second.name))";
    }
    override public var properties: Array<PropertyIterableProperty<Any?, Any?>> {
        get { return self.first.properties + [self.second] }
    }
    override public func mapCondition(_ condition: Condition<V?>) -> Condition<K> {
        return self.first.mapCondition(ConditionIfNotNull(ConditionOnField(key: self.second, condition: condition)));
    }
    override public func mapModification(_ modification: Modification<V?>) -> Modification<K> {
        return self.first.mapModification(ModificationIfNotNull(ModificationOnField(key: self.second, modification: modification)));
    }
}
//data class PropertyPathKeyAccess<K, V>(val first: PropertyPath<K, Map<String, V>>, val index: String): PropertyPath<K, V?>() {
    //    override fun get(key: K): V? = first.get(key).get(index)
    //    override fun set(key: K, value: V?): K = first.get(key).let {
        //        first.set(key, it.toMutableMap().also {
            //            if(value == null) it.remove(index)
            //            else it[index] = value
        //        })
    //    }
    //    override fun toString(): String = "$first.$index"
    //    override val properties: List<KProperty1<*, *>> get() = first.properties
//}
//data class PropertyPathSafeKeyAccess<K, V>(val first: PropertyPath<K, Map<String, V>?>, val index: String): PropertyPath<K, V?>() {
    //    override fun get(key: K): V? = first.get(key)?.get(index)
    //    override fun set(key: K, value: V?): K = first.get(key).let {
        //        first.set(key, it?.toMutableMap()?.also {
            //            if(value == null) it.remove(index)
            //            else it[index] = value
        //        })
    //    }
    //    override fun toString(): String = "$first.$index"
    //    override val properties: List<KProperty1<*, *>> get() = first.properties
//}

public extension PropertyPath {
    func get<V2>(prop: PropertyIterableProperty<V, V2>) -> PropertyPathAccess<K, V, V2> {
        return PropertyPathAccess(first: self, second: prop);
    }
}
public func xPropertyPathSafeGet<K, V : Any, V2>(_ this: PropertyPath<K, V?>, prop: PropertyIterableProperty<V, V2>) -> PropertyPathSafeAccess<K, V, V2> {
    return PropertyPathSafeAccess(first: this, second: prop);
}


public func path<T : Codable & Hashable>() -> PropertyPath<T, T> {
    return PropertyPathSelf();
}
//operator fun <K, V : IsCodableAndHashable> PropertyPath<K, Map<String, V>>.get(key: String) = PropertyPathKeyAccess(this, key)
//operator fun <K, V : IsCodableAndHashable> PropertyPath<K, Map<String, V>?>.get(key: String) = PropertyPathSafeKeyAccess(this, key)

public func condition<T : Codable & Hashable>(setup: @escaping (PropertyPath<T, T>) -> Condition<T>) -> Condition<T> {
    return (setup)((path() as PropertyPath<T, T>));
}

