// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class CollectionChanges<T : Codable & Hashable> : CustomStringConvertible, Hashable, Codable {
    public var changes: Array<EntryChange<T>>
    public var replace: Array<T>?
    public init(changes: Array<EntryChange<T>> = [], replace: Array<T>? = nil) {
        self.changes = changes
        self.replace = replace
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            changes: values.contains(.changes) ? try values.decode(Array<EntryChange<T>>.self, forKey: .changes) : [],
            replace: values.contains(.replace) ? try values.decode(Array<T>?.self, forKey: .replace) : nil
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case changes = "changes"
        case replace = "replace"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.changes, forKey: .changes)
        try container.encodeIfPresent(self.replace, forKey: .replace)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(changes)
        hasher.combine(replace)
        
    }
    public static func == (lhs: CollectionChanges, rhs: CollectionChanges) -> Bool { return lhs.changes == rhs.changes && lhs.replace == rhs.replace }
    public var description: String { return "CollectionChanges(changes=\(String(kotlin: self.changes)), replace=\(String(kotlin: self.replace)))" }
    public func copy(changes: Array<EntryChange<T>>? = nil, replace: Array<T>?? = .some(nil)) -> CollectionChanges<T> { return CollectionChanges(changes: changes ?? self.changes, replace: invertOptional(replace) ?? self.replace) }
    
    public convenience init(old: T? = nil, new: T? = nil) {
        self.init(changes: old != nil || new != nil ? [EntryChange(old: old, new: new)] : [])
    }
}

public extension Array where Element : HasId {
    func apply(changes: CollectionChanges<Element>) -> Array<Element> {
        if changes.replace != nil {
            return changes.replace!
        }
        var changeable = Array(self)
        for change in (changes.changes){
            if let old = (change.old) {
                changeable.removeAll(where: { (it) -> Bool in it._id == old._id })
            }
            if let new = (change.new) {
                changeable.append(new)
            }
        }
        return changeable
    }
}

public extension CollectionChanges where T : Codable & Hashable {
    func map<B : Codable & Hashable>(mapper: @escaping (T) -> B) -> CollectionChanges<B> {
        return (CollectionChanges<B>(changes: self.changes.map({ (it) -> EntryChange<B> in it.map(mapper: mapper) }) as Array<EntryChange<B>>, replace: self.replace?.map(mapper) as Array<B>?) as CollectionChanges<B>)
    }
}
