// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

open class Modification<T : Codable & Hashable> : KEquatable, KHashable {
    public init() {
        //Necessary properties should be initialized now
    }
    
    open func hashCode() -> Int { fatalError() }
    open func equals(other: Any) -> Bool { fatalError() }
    open func invoke(on: T) -> T { fatalError() }
    open func invokeDefault() -> T { fatalError() }
    
    public func then(other: Modification<T>) -> ModificationChain<T> {
        return ModificationChain(modifications: [self, other]);
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}

public final class ModificationChain<T : Codable & Hashable> : Modification<T>, CustomStringConvertible {
    public var modifications: Array<Modification<T>>
    public init(modifications: Array<Modification<T>>) {
        self.modifications = modifications
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(modifications)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationChain else { return false }
        return self.modifications == other.modifications
    }
    public var description: String { return "ModificationChain(modifications=\(String(kotlin: self.modifications)))" }
    public func copy(modifications: Array<Modification<T>>? = nil) -> ModificationChain<T> { return ModificationChain(modifications: modifications ?? self.modifications) }
    
    override public func invoke(on: T) -> T {
        return self.modifications.reduce(on, { (item, mod) -> T in mod.invoke(on: item) });
    }
    override public func invokeDefault() -> T {
        let on = self.modifications[0].invokeDefault()
        return Array(self.modifications.dropFirst(1)).reduce(on, { (item, mod) -> T in mod.invoke(on: item) })
    }
}
public final class ModificationIfNotNull<T : Codable & Hashable> : Modification<T?>, CustomStringConvertible {
    public var modification: Modification<T>
    public init(_ modification: Modification<T>) {
        self.modification = modification
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(modification)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationIfNotNull else { return false }
        return self.modification == other.modification
    }
    public var description: String { return "ModificationIfNotNull(modification=\(String(kotlin: self.modification)))" }
    public func copy(_ modification: Modification<T>? = nil) -> ModificationIfNotNull<T> { return ModificationIfNotNull(modification ?? self.modification) }
    
    override public func invoke(on: T?) -> T? {
        return on.flatMap { temp79 in ({ (it) -> T in self.modification.invoke(on: it) })(temp79) };
    }
    override public func invokeDefault() -> T? {
        return nil;
    }
}
public final class ModificationAssign<T : Codable & Hashable> : Modification<T>, CustomStringConvertible {
    public var value: T
    public init(_ value: T) {
        self.value = value
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(value)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationAssign else { return false }
        return self.value == other.value
    }
    public var description: String { return "ModificationAssign(value=\(String(kotlin: self.value)))" }
    public func copy(_ value: T? = nil) -> ModificationAssign<T> { return ModificationAssign(value ?? self.value) }
    
    override public func invoke(on: T) -> T {
        return self.value;
    }
    override public func invokeDefault() -> T {
        return self.value;
    }
}
public final class ModificationCoerceAtMost<T : Codable & Hashable & Comparable> : Modification<T>, CustomStringConvertible {
    public var value: T
    public init(_ value: T) {
        self.value = value
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(value)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationCoerceAtMost else { return false }
        return self.value == other.value
    }
    public var description: String { return "ModificationCoerceAtMost(value=\(String(kotlin: self.value)))" }
    public func copy(_ value: T? = nil) -> ModificationCoerceAtMost<T> { return ModificationCoerceAtMost(value ?? self.value) }
    
    override public func invoke(on: T) -> T {
        return Swift.min(on, self.value);
    }
    override public func invokeDefault() -> T {
        return self.value;
    }
}
public final class ModificationCoerceAtLeast<T : Codable & Hashable & Comparable> : Modification<T>, CustomStringConvertible {
    public var value: T
    public init(_ value: T) {
        self.value = value
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(value)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationCoerceAtLeast else { return false }
        return self.value == other.value
    }
    public var description: String { return "ModificationCoerceAtLeast(value=\(String(kotlin: self.value)))" }
    public func copy(_ value: T? = nil) -> ModificationCoerceAtLeast<T> { return ModificationCoerceAtLeast(value ?? self.value) }
    
    override public func invoke(on: T) -> T {
        return Swift.max(on, self.value);
    }
    override public func invokeDefault() -> T {
        return self.value;
    }
}
public final class ModificationIncrement<T : Number> : Modification<T>, CustomStringConvertible {
    public var by: T
    public init(by: T) {
        self.by = by
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(by)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationIncrement else { return false }
        return self.by == other.by
    }
    public var description: String { return "ModificationIncrement(by=\(String(kotlin: self.by)))" }
    public func copy(by: T? = nil) -> ModificationIncrement<T> { return ModificationIncrement(by: by ?? self.by) }
    
    override public func invoke(on: T) -> T {
        return on.plus(other: self.by);
    }
    override public func invokeDefault() -> T {
        return self.by;
    }
}
public final class ModificationMultiply<T : Number> : Modification<T>, CustomStringConvertible {
    public var by: T
    public init(by: T) {
        self.by = by
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(by)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationMultiply else { return false }
        return self.by == other.by
    }
    public var description: String { return "ModificationMultiply(by=\(String(kotlin: self.by)))" }
    public func copy(by: T? = nil) -> ModificationMultiply<T> { return ModificationMultiply(by: by ?? self.by) }
    
    override public func invoke(on: T) -> T {
        return on.times(other: self.by);
    }
    override public func invokeDefault() -> T {
        return run { () -> T in
            if self.by is Int8 {
                return Int8(0) as! T
            } else if self.by is Int16 {
                return Int16(0) as! T
            } else if self.by is Int {
                return 0 as! T
            } else if self.by is Int {
                return 0 as! T
            } else if self.by is Float {
                return 0 as! T
            } else if self.by is Double {
                return 0.0 as! T
            } else  {
                fatalError()
            }
        };
    }
}
public final class ModificationAppendString : Modification<String>, CustomStringConvertible {
    public var value: String
    public init(_ value: String) {
        self.value = value
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(value)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationAppendString else { return false }
        return self.value == other.value
    }
    public var description: String { return "ModificationAppendString(value=\(String(kotlin: self.value)))" }
    public func copy(_ value: String? = nil) -> ModificationAppendString { return ModificationAppendString(value ?? self.value) }
    
    override public func invoke(on: String) -> String {
        return on + self.value;
    }
    override public func invokeDefault() -> String {
        return self.value;
    }
}
public final class ModificationAppendList<T : Codable & Hashable> : Modification<Array<T>>, CustomStringConvertible {
    public var items: Array<T>
    public init(items: Array<T>) {
        self.items = items
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(items)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationAppendList else { return false }
        return self.items == other.items
    }
    public var description: String { return "ModificationAppendList(items=\(String(kotlin: self.items)))" }
    public func copy(items: Array<T>? = nil) -> ModificationAppendList<T> { return ModificationAppendList(items: items ?? self.items) }
    
    override public func invoke(on: Array<T>) -> Array<T> {
        return on + self.items;
    }
    override public func invokeDefault() -> Array<T> {
        return self.items;
    }
}
public final class ModificationAppendSet<T : Codable & Hashable> : Modification<Array<T>>, CustomStringConvertible {
    public var items: Array<T>
    public init(items: Array<T>) {
        self.items = items
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(items)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationAppendSet else { return false }
        return self.items == other.items
    }
    public var description: String { return "ModificationAppendSet(items=\(String(kotlin: self.items)))" }
    public func copy(items: Array<T>? = nil) -> ModificationAppendSet<T> { return ModificationAppendSet(items: items ?? self.items) }
    
    override public func invoke(on: Array<T>) -> Array<T> {
        return Array(Set((on + self.items)));
    }
    override public func invokeDefault() -> Array<T> {
        return self.items;
    }
}
public final class ModificationRemove<T : Codable & Hashable> : Modification<Array<T>>, CustomStringConvertible {
    public var condition: Condition<T>
    public init(_ condition: Condition<T>) {
        self.condition = condition
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(condition)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationRemove else { return false }
        return self.condition == other.condition
    }
    public var description: String { return "ModificationRemove(condition=\(String(kotlin: self.condition)))" }
    public func copy(_ condition: Condition<T>? = nil) -> ModificationRemove<T> { return ModificationRemove(condition ?? self.condition) }
    
    override public func invoke(on: Array<T>) -> Array<T> {
        return on.filter({ (it) -> Bool in (!self.condition.invoke(on: it)) });
    }
    override public func invokeDefault() -> Array<T> {
        return [];
    }
}
public final class ModificationRemoveInstances<T : Codable & Hashable> : Modification<Array<T>>, CustomStringConvertible {
    public var items: Array<T>
    public init(items: Array<T>) {
        self.items = items
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(items)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationRemoveInstances else { return false }
        return self.items == other.items
    }
    public var description: String { return "ModificationRemoveInstances(items=\(String(kotlin: self.items)))" }
    public func copy(items: Array<T>? = nil) -> ModificationRemoveInstances<T> { return ModificationRemoveInstances(items: items ?? self.items) }
    
    override public func invoke(on: Array<T>) -> Array<T> {
        return on.minus(elements: self.items);
    }
    override public func invokeDefault() -> Array<T> {
        return [];
    }
}
public final class ModificationDropFirst<T : Codable & Hashable> : Modification<Array<T>> {
    override public init() {
        super.init()
        //Necessary properties should be initialized now
    }
    
    override public func invoke(on: Array<T>) -> Array<T> {
        return Array(on.dropFirst(1));
    }
    override public func invokeDefault() -> Array<T> {
        return [];
    }
    override public func hashCode() -> Int {
        return 1;
    }
    override public func equals(other: Any) -> Bool {
        return (other as? ModificationDropFirst<T>) != nil;
    }
}
public final class ModificationDropLast<T : Codable & Hashable> : Modification<Array<T>> {
    override public init() {
        super.init()
        //Necessary properties should be initialized now
    }
    
    override public func invoke(on: Array<T>) -> Array<T> {
        return Array(on.dropLast(1));
    }
    override public func invokeDefault() -> Array<T> {
        return [];
    }
    override public func hashCode() -> Int {
        return 1;
    }
    override public func equals(other: Any) -> Bool {
        return (other as? ModificationDropLast<T>) != nil;
    }
}
public final class ModificationPerElement<T : Codable & Hashable> : Modification<Array<T>>, CustomStringConvertible, Codable {
    public var condition: Condition<T>
    public var modification: Modification<T>
    public init(condition: Condition<T>, modification: Modification<T>) {
        self.condition = condition
        self.modification = modification
        super.init()
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            condition: try values.decode(Condition<T>.self, forKey: .condition),
            modification: try values.decode(Modification<T>.self, forKey: .modification)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case condition = "condition"
        case modification = "modification"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.condition, forKey: .condition)
        try container.encode(self.modification, forKey: .modification)
    }
    
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(condition)
        hasher.combine(modification)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationPerElement else { return false }
        return self.condition == other.condition && self.modification == other.modification
    }
    public var description: String { return "ModificationPerElement(condition=\(String(kotlin: self.condition)), modification=\(String(kotlin: self.modification)))" }
    public func copy(condition: Condition<T>? = nil, modification: Modification<T>? = nil) -> ModificationPerElement<T> { return ModificationPerElement(condition: condition ?? self.condition, modification: modification ?? self.modification) }
    
    override public func invoke(on: Array<T>) -> Array<T> {
        return on.map({ (it) -> T in self.condition.invoke(on: it) ? self.modification.invoke(on: it) : it });
    }
    override public func invokeDefault() -> Array<T> {
        return [];
    }
}
public final class ModificationCombine<T : Codable & Hashable> : Modification<Dictionary<String, T>>, CustomStringConvertible {
    public var map: Dictionary<String, T>
    public init(_ map: Dictionary<String, T>) {
        self.map = map
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(map)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationCombine else { return false }
        return self.map == other.map
    }
    public var description: String { return "ModificationCombine(map=\(String(kotlin: self.map)))" }
    public func copy(_ map: Dictionary<String, T>? = nil) -> ModificationCombine<T> { return ModificationCombine(map ?? self.map) }
    
    override public func invoke(on: Dictionary<String, T>) -> Dictionary<String, T> {
        return on.plus(self.map);
    }
    override public func invokeDefault() -> Dictionary<String, T> {
        return self.map;
    }
}
public final class ModificationModifyByKey<T : Codable & Hashable> : Modification<Dictionary<String, T>>, CustomStringConvertible {
    public var map: Dictionary<String, Modification<T>>
    public init(_ map: Dictionary<String, Modification<T>>) {
        self.map = map
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(map)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationModifyByKey else { return false }
        return self.map == other.map
    }
    public var description: String { return "ModificationModifyByKey(map=\(String(kotlin: self.map)))" }
    public func copy(_ map: Dictionary<String, Modification<T>>? = nil) -> ModificationModifyByKey<T> { return ModificationModifyByKey(map ?? self.map) }
    
    override public func invoke(on: Dictionary<String, T>) -> Dictionary<String, T> {
        return on.plus(self.map.mapValuesFromPairs({ (it) -> T in ((on[it.key]).map { (e) in
            return it.value.invoke(on: e)
        } ?? it.value.invokeDefault()) }));
    }
    override public func invokeDefault() -> Dictionary<String, T> {
        return self.map.mapValuesFromPairs({ (it) -> T in it.value.invokeDefault() });
    }
}
public final class ModificationRemoveKeys<T : Codable & Hashable> : Modification<Dictionary<String, T>>, CustomStringConvertible {
    public var fields: Set<String>
    public init(fields: Set<String>) {
        self.fields = fields
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(fields)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationRemoveKeys else { return false }
        return self.fields == other.fields
    }
    public var description: String { return "ModificationRemoveKeys(fields=\(String(kotlin: self.fields)))" }
    public func copy(fields: Set<String>? = nil) -> ModificationRemoveKeys<T> { return ModificationRemoveKeys(fields: fields ?? self.fields) }
    
    override public func invoke(on: Dictionary<String, T>) -> Dictionary<String, T> {
        return on.filter { (key, value) in
            let it = key
            return !(self.fields.contains(it))
        };
    }
    override public func invokeDefault() -> Dictionary<String, T> {
        return dictionaryOf();
    }
}
public final class ModificationOnField<K : Codable & Hashable, V : Codable & Hashable> : Modification<K>, CustomStringConvertible {
    public var key: PropertyIterableProperty<K, V>
    public var modification: Modification<V>
    public init(key: PropertyIterableProperty<K, V>, modification: Modification<V>) {
        self.key = key
        self.modification = modification
        super.init()
        //Necessary properties should be initialized now
    }
    override public func hashCode() -> Int {
        var hasher = Hasher()
        hasher.combine(key)
        hasher.combine(modification)
        return hasher.finalize()
    }
    override public func equals(other: Any) -> Bool {
        guard let other = other as? ModificationOnField else { return false }
        return self.key == other.key && self.modification == other.modification
    }
    public var description: String { return "ModificationOnField(key=\(String(kotlin: self.key)), modification=\(String(kotlin: self.modification)))" }
    public func copy(key: PropertyIterableProperty<K, V>? = nil, modification: Modification<V>? = nil) -> ModificationOnField<K, V> { return ModificationOnField(key: key ?? self.key, modification: modification ?? self.modification) }
    
    override public func invoke(on: K) -> K {
        return self.key.set(on, self.modification.invoke(on: self.key.get(on)));
    }
    override public func invokeDefault() -> K {
        fatalError("Cannot mutate a field that doesn't exist")
    }
}
