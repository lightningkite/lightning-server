// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class GroupCountQuery<Model : Codable & Hashable> : CustomStringConvertible, Hashable, Codable {
    public var condition: Condition<Model>
    public var groupBy: PartialPropertyIterableProperty<Model>
    public init(_ condition: Condition<Model> = ConditionAlways(), groupBy: PartialPropertyIterableProperty<Model>) {
        self.condition = condition
        self.groupBy = groupBy
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            values.contains(.condition) ? try values.decode(Condition<Model>.self, forKey: .condition) : ConditionAlways(),
            groupBy: try values.decode(PartialPropertyIterableProperty<Model>.self, forKey: .groupBy)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case condition = "condition"
        case groupBy = "groupBy"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.condition, forKey: .condition)
        try container.encode(self.groupBy, forKey: .groupBy)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(condition)
        hasher.combine(groupBy)
        
    }
    public static func == (lhs: GroupCountQuery, rhs: GroupCountQuery) -> Bool { return lhs.condition == rhs.condition && lhs.groupBy == rhs.groupBy }
    public var description: String { return "GroupCountQuery(condition=\(String(kotlin: self.condition)), groupBy=\(String(kotlin: self.groupBy)))" }
    public func copy(_ condition: Condition<Model>? = nil, groupBy: PartialPropertyIterableProperty<Model>? = nil) -> GroupCountQuery<Model> { return GroupCountQuery(condition ?? self.condition, groupBy: groupBy ?? self.groupBy) }
}

public final class AggregateQuery<Model : Codable & Hashable> : CustomStringConvertible, Hashable, Codable {
    public var aggregate: Aggregate
    public var condition: Condition<Model>
    public var property: PartialPropertyIterableProperty<Model>
    public init(_ aggregate: Aggregate, condition: Condition<Model> = ConditionAlways(), property: PartialPropertyIterableProperty<Model>) {
        self.aggregate = aggregate
        self.condition = condition
        self.property = property
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            try values.decode(Aggregate.self, forKey: .aggregate),
            condition: values.contains(.condition) ? try values.decode(Condition<Model>.self, forKey: .condition) : ConditionAlways(),
            property: try values.decode(PartialPropertyIterableProperty<Model>.self, forKey: .property)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case aggregate = "aggregate"
        case condition = "condition"
        case property = "property"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.aggregate, forKey: .aggregate)
        try container.encode(self.condition, forKey: .condition)
        try container.encode(self.property, forKey: .property)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(aggregate)
        hasher.combine(condition)
        hasher.combine(property)
        
    }
    public static func == (lhs: AggregateQuery, rhs: AggregateQuery) -> Bool { return lhs.aggregate == rhs.aggregate && lhs.condition == rhs.condition && lhs.property == rhs.property }
    public var description: String { return "AggregateQuery(aggregate=\(String(kotlin: self.aggregate)), condition=\(String(kotlin: self.condition)), property=\(String(kotlin: self.property)))" }
    public func copy(_ aggregate: Aggregate? = nil, condition: Condition<Model>? = nil, property: PartialPropertyIterableProperty<Model>? = nil) -> AggregateQuery<Model> { return AggregateQuery(aggregate ?? self.aggregate, condition: condition ?? self.condition, property: property ?? self.property) }
}

public final class GroupAggregateQuery<Model : Codable & Hashable> : CustomStringConvertible, Hashable, Codable {
    public var aggregate: Aggregate
    public var condition: Condition<Model>
    public var groupBy: PartialPropertyIterableProperty<Model>
    public var property: PartialPropertyIterableProperty<Model>
    public init(_ aggregate: Aggregate, condition: Condition<Model> = ConditionAlways(), groupBy: PartialPropertyIterableProperty<Model>, property: PartialPropertyIterableProperty<Model>) {
        self.aggregate = aggregate
        self.condition = condition
        self.groupBy = groupBy
        self.property = property
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            try values.decode(Aggregate.self, forKey: .aggregate),
            condition: values.contains(.condition) ? try values.decode(Condition<Model>.self, forKey: .condition) : ConditionAlways(),
            groupBy: try values.decode(PartialPropertyIterableProperty<Model>.self, forKey: .groupBy),
            property: try values.decode(PartialPropertyIterableProperty<Model>.self, forKey: .property)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case aggregate = "aggregate"
        case condition = "condition"
        case groupBy = "groupBy"
        case property = "property"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.aggregate, forKey: .aggregate)
        try container.encode(self.condition, forKey: .condition)
        try container.encode(self.groupBy, forKey: .groupBy)
        try container.encode(self.property, forKey: .property)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(aggregate)
        hasher.combine(condition)
        hasher.combine(groupBy)
        hasher.combine(property)
        
    }
    public static func == (lhs: GroupAggregateQuery, rhs: GroupAggregateQuery) -> Bool { return lhs.aggregate == rhs.aggregate && lhs.condition == rhs.condition && lhs.groupBy == rhs.groupBy && lhs.property == rhs.property }
    public var description: String { return "GroupAggregateQuery(aggregate=\(String(kotlin: self.aggregate)), condition=\(String(kotlin: self.condition)), groupBy=\(String(kotlin: self.groupBy)), property=\(String(kotlin: self.property)))" }
    public func copy(_ aggregate: Aggregate? = nil, condition: Condition<Model>? = nil, groupBy: PartialPropertyIterableProperty<Model>? = nil, property: PartialPropertyIterableProperty<Model>? = nil) -> GroupAggregateQuery<Model> { return GroupAggregateQuery(aggregate ?? self.aggregate, condition: condition ?? self.condition, groupBy: groupBy ?? self.groupBy, property: property ?? self.property) }
}

