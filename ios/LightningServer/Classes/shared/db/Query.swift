// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class Query<T : Codable & Hashable> : CustomStringConvertible, Hashable, Codable {
    public var condition: Condition<T>
    public var orderBy: Array<SortPart<T>>
    public var skip: Int
    public var limit: Int
    public init(_ condition: Condition<T> = ConditionAlways(), orderBy: Array<SortPart<T>> = [], skip: Int = 0, limit: Int = 100) {
        self.condition = condition
        self.orderBy = orderBy
        self.skip = skip
        self.limit = limit
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            values.contains(.condition) ? try values.decode(Condition<T>.self, forKey: .condition) : ConditionAlways(),
            orderBy: values.contains(.orderBy) ? try values.decode(Array<SortPart<T>>.self, forKey: .orderBy) : [],
            skip: values.contains(.skip) ? try values.decode(Int.self, forKey: .skip) : 0,
            limit: values.contains(.limit) ? try values.decode(Int.self, forKey: .limit) : 100
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case condition = "condition"
        case orderBy = "orderBy"
        case skip = "skip"
        case limit = "limit"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.condition, forKey: .condition)
        try container.encode(self.orderBy, forKey: .orderBy)
        try container.encode(self.skip, forKey: .skip)
        try container.encode(self.limit, forKey: .limit)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(condition)
        hasher.combine(orderBy)
        hasher.combine(skip)
        hasher.combine(limit)
        
    }
    public static func == (lhs: Query, rhs: Query) -> Bool { return lhs.condition == rhs.condition && lhs.orderBy == rhs.orderBy && lhs.skip == rhs.skip && lhs.limit == rhs.limit }
    public var description: String { return "Query(condition=\(String(kotlin: self.condition)), orderBy=\(String(kotlin: self.orderBy)), skip=\(String(kotlin: self.skip)), limit=\(String(kotlin: self.limit)))" }
    public func copy(_ condition: Condition<T>? = nil, orderBy: Array<SortPart<T>>? = nil, skip: Int? = nil, limit: Int? = nil) -> Query<T> { return Query(condition ?? self.condition, orderBy: orderBy ?? self.orderBy, skip: skip ?? self.skip, limit: limit ?? self.limit) }
    
    public convenience init(orderBy: Array<SortPart<T>> = [], skip: Int = 0, limit: Int = 100, makeCondition: @escaping (PropChain<T, T>) -> Condition<T>) {
        self.init(makeCondition(startChain()), orderBy: orderBy, skip: skip, limit: limit)
    }
}
