// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public func modification<T : Codable & Hashable>(setup: @escaping (ModificationBuilder<T>, PropChain<T, T>) -> Void) -> Modification<T> {
    return also((ModificationBuilder() as ModificationBuilder<T>), { (this) -> Void in setup(this, startChain()) }).build()
}

public final class ModificationBuilder<K : Codable & Hashable> {
    public init() {
        self.modifications = [] as Array<Modification<K>>
        //Necessary properties should be initialized now
    }
    
    public var modifications: Array<Modification<K>>
    public func build() -> Modification<K> {
        return run {var temp104 = self.modifications
            (temp104.count == 1 ? temp104[0] : nil)self.modifications = temp104
        } ?? ModificationChain(modifications: self.modifications);
    }
    
    public func xPropChainAssign(_ this: PropChain<K, T>, _ value: T) -> Void {
        self.modifications.append(this.mapModification(ModificationAssign(value)))
    }
    
    public func xPropChainCoerceAtMost(_ this: PropChain<K, T>, _ value: T) -> Void {
        self.modifications.append(this.mapModification(ModificationCoerceAtMost(value)))
    }
    
    public func xPropChainCoerceAtLeast(_ this: PropChain<K, T>, _ value: T) -> Void {
        self.modifications.append(this.mapModification(ModificationCoerceAtLeast(value)))
    }
    
    public func xPropChainPlus(_ this: PropChain<K, T>, by: T) -> Void {
        self.modifications.append(this.mapModification(ModificationIncrement(by: by)))
    }
    
    public func xPropChainTimes(_ this: PropChain<K, T>, by: T) -> Void {
        self.modifications.append(this.mapModification(ModificationMultiply(by: by)))
    }
    
    public func xPropChainPlus(_ this: PropChain<K, String>, _ value: String) -> Void {
        self.modifications.append(this.mapModification(ModificationAppendString(value)))
    }
    
    public func xPropChainPlus<T>(_ this: PropChain<K, Array<T>>, items: Array<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationListAppend(items: items)))
    }
    
    public func xPropChainPlus<T>(_ this: PropChain<K, Set<T>>, items: Set<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationSetAppend(items: items)))
    }
    
    public func xPropChainPlus<T>(_ this: PropChain<K, Array<T>>, item: T) -> Void {
        self.modifications.append(this.mapModification(ModificationListAppend(items: [item])))
    }
    
    public func xPropChainPlus<T>(_ this: PropChain<K, Set<T>>, item: T) -> Void {
        self.modifications.append(this.mapModification(ModificationSetAppend(items: ([item] as Set<T>))))
    }
    
    public func xPropChainPlusAssign(_ this: PropChain<K, T>, by: T) -> Void {
        self.modifications.append(this.mapModification(ModificationIncrement(by: by)))
    }
    
    public func xPropChainTimesAssign(_ this: PropChain<K, T>, by: T) -> Void {
        self.modifications.append(this.mapModification(ModificationMultiply(by: by)))
    }
    
    public func xPropChainPlusAssign(_ this: PropChain<K, String>, _ value: String) -> Void {
        self.modifications.append(this.mapModification(ModificationAppendString(value)))
    }
    
    public func xPropChainPlusAssign<T>(_ this: PropChain<K, Array<T>>, items: Array<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationListAppend(items: items)))
    }
    
    public func xPropChainPlusAssign<T>(_ this: PropChain<K, Set<T>>, items: Set<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationSetAppend(items: items)))
    }
    
    public func xPropChainPlusAssign<T>(_ this: PropChain<K, Array<T>>, item: T) -> Void {
        self.modifications.append(this.mapModification(ModificationListAppend(items: [item])))
    }
    
    public func xPropChainPlusAssign<T>(_ this: PropChain<K, Set<T>>, item: T) -> Void {
        self.modifications.append(this.mapModification(ModificationSetAppend(items: ([item] as Set<T>))))
    }
    
    public func xPropChainAddAll<T : Codable & Hashable>(_ this: PropChain<K, Array<T>>, items: Array<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationListAppend(items: items)))
    }
    
    public func xPropChainAddAll<T : Codable & Hashable>(_ this: PropChain<K, Set<T>>, items: Set<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationSetAppend(items: items)))
    }
    
    public func xPropChainRemoveAll<T : Codable & Hashable>(_ this: PropChain<K, Array<T>>, condition: @escaping (PropChain<T, T>) -> Condition<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationListRemove((condition)((startChain() as PropChain<T, T>)))))
    }
    
    public func xPropChainRemoveAll<T : Codable & Hashable>(_ this: PropChain<K, Set<T>>, condition: @escaping (PropChain<T, T>) -> Condition<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationSetRemove((condition)((startChain() as PropChain<T, T>)))))
    }
    
    public func xPropChainRemoveAll<T : Codable & Hashable>(_ this: PropChain<K, Array<T>>, items: Array<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationListRemoveInstances(items: items)))
    }
    
    public func xPropChainRemoveAll<T : Codable & Hashable>(_ this: PropChain<K, Set<T>>, items: Set<T>) -> Void {
        self.modifications.append(this.mapModification(ModificationSetRemoveInstances(items: items)))
    }
    
    public func xPropChainDropLast<T : Codable & Hashable>(_ this: PropChain<K, Array<T>>) -> Void {
        self.modifications.append(this.mapModification(ModificationListDropLast()))
    }
    
    public func xPropChainDropLast<T : Codable & Hashable>(_ this: PropChain<K, Set<T>>) -> Void {
        self.modifications.append(this.mapModification(ModificationSetDropLast()))
    }
    
    public func xPropChainDropFirst<T : Codable & Hashable>(_ this: PropChain<K, Array<T>>) -> Void {
        self.modifications.append(this.mapModification(ModificationListDropFirst()))
    }
    
    public func xPropChainDropFirst<T : Codable & Hashable>(_ this: PropChain<K, Set<T>>) -> Void {
        self.modifications.append(this.mapModification(ModificationSetDropFirst()))
    }
    
    public func xPropChainMap<T : Codable & Hashable>(_ this: PropChain<K, Array<T>>, modification: @escaping (ModificationBuilder<T>, PropChain<T, T>) -> Void) -> Void {
        self.modifications.append(this.mapModification(
            ModificationListPerElement(condition: ConditionAlways(), modification: also((ModificationBuilder<T>() as ModificationBuilder<T>), { (this1) -> Void in modification(this1, startChain()) }).build())
        ))
    }
    
    public func xPropChainMap<T : Codable & Hashable>(_ this: PropChain<K, Set<T>>, modification: @escaping (ModificationBuilder<T>, PropChain<T, T>) -> Void) -> Void {
        self.modifications.append(this.mapModification(
            ModificationSetPerElement(condition: ConditionAlways(), modification: also((ModificationBuilder<T>() as ModificationBuilder<T>), { (this1) -> Void in modification(this1, startChain()) }).build())
        ))
    }
    
    public func xPropChainMapIf<T : Codable & Hashable>(_ this: PropChain<K, Array<T>>, condition: @escaping (PropChain<T, T>) -> Condition<T>, modification: @escaping (ModificationBuilder<T>, PropChain<T, T>) -> Void) -> Void {
        self.modifications.append(this.mapModification(
            ModificationListPerElement(condition: (condition)((startChain() as PropChain<T, T>)), modification: also((ModificationBuilder<T>() as ModificationBuilder<T>), { (this1) -> Void in modification(this1, startChain()) }).build())
        ))
    }
    
    public func xPropChainMapIf<T : Codable & Hashable>(_ this: PropChain<K, Set<T>>, condition: @escaping (PropChain<T, T>) -> Condition<T>, modification: @escaping (ModificationBuilder<T>, PropChain<T, T>) -> Void) -> Void {
        self.modifications.append(this.mapModification(
            ModificationSetPerElement(condition: (condition)((startChain() as PropChain<T, T>)), modification: also((ModificationBuilder<T>() as ModificationBuilder<T>), { (this1) -> Void in modification(this1, startChain()) }).build())
        ))
    }
    
    public func xPropChainPlus<T : Codable & Hashable>(_ this: PropChain<K, Dictionary<String, T>>, _ map: Dictionary<String, T>) -> Void {
        self.modifications.append(this.mapModification(ModificationCombine(map)))
    }
    
    public func xPropChainModifyByKey<T : Codable & Hashable>(_ this: PropChain<K, Dictionary<String, T>>, modifications: Dictionary<String, (ModificationBuilder<T>, PropChain<T, T>) -> Void>) -> Void {
        self.modifications.append(this.mapModification(ModificationModifyByKey(modifications.mapValuesFromPairs({ (it) -> Modification<T> in modification(setup: it.value) }))))
    }
    
    public func xPropChainRemoveKeys<T : Codable & Hashable>(_ this: PropChain<K, Dictionary<String, T>>, fields: Set<String>) -> Void {
        self.modifications.append(this.mapModification(ModificationRemoveKeys(fields: fields)))
    }
    
}
