// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - customized
import KhrysalisRuntime
import Foundation

public final class SortPart<T : Codable & Hashable> : CustomStringConvertible, Hashable {
    public var field: DataClassPathPartial<T>
    public var ascending: Bool
    public var ignoreCase: Bool
    public init(field: DataClassPathPartial<T>, ascending: Bool = true, ignoreCase: Bool = false) {
        self.field = field
        self.ascending = ascending
        self.ignoreCase = ignoreCase
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(field)
        hasher.combine(ascending)
        hasher.combine(ignoreCase)
        
    }
    public static func == (lhs: SortPart, rhs: SortPart) -> Bool { return lhs.field == rhs.field && lhs.ascending == rhs.ascending && lhs.ignoreCase == rhs.ignoreCase }
    public var description: String { return "SortPart(field=\(String(kotlin: self.field)), ascending=\(String(kotlin: self.ascending)), ignoreCase=\(String(kotlin: self.ignoreCase)))" }
    public func copy(field: DataClassPathPartial<T>? = nil, ascending: Bool? = nil, ignoreCase: Bool? = nil) -> SortPart<T> { return SortPart(field: field ?? self.field, ascending: ascending ?? self.ascending, ignoreCase: ignoreCase ?? self.ignoreCase) }
    
    public convenience init<V: Codable & Hashable>(field: PropertyIterableProperty<T, V>, ascending: Bool = true, ignoreCase: Bool = false) {
        self.init(field: DataClassPathAccess(first: DataClassPathSelf(), second: field), ascending: ascending, ignoreCase: ignoreCase)
    }
}

public func getListComparator<T : Codable & Hashable>(_ this: Array<SortPart<T>>) -> TypedComparator<T>? {
    if this.isEmpty { return nil }
    return makeComparator(function: { (a, b) -> Int in
        for part in (this){
            if part.ignoreCase {
                let aString = part.field.getAny(key: a) as! String
                let bString = part.field.getAny(key: b) as! String
                let result = aString.lowercased().compareTo(other: bString.lowercased())
                if result != 0 { return part.ascending ? result : (-result) }
            } else {
                let result = part.field.compare(a, b).rawValue
                if result != 0 { return part.ascending ? result : (-result) }
            }
        }
        return 0
    } as (T, T)->Int)
}

