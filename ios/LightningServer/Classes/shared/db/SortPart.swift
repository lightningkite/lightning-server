// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class SortPart<T : Codable & Hashable> : CustomStringConvertible, Hashable {
    public var field: PartialPropertyIterableProperty<T>
    public var ascending: Bool
    public init(field: PartialPropertyIterableProperty<T>, ascending: Bool = true) {
        self.field = field
        self.ascending = ascending
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(field)
        hasher.combine(ascending)
        
    }
    public static func == (lhs: SortPart, rhs: SortPart) -> Bool { return lhs.field == rhs.field && lhs.ascending == rhs.ascending }
    public var description: String { return "SortPart(field=\(String(kotlin: self.field)), ascending=\(String(kotlin: self.ascending)))" }
    public func copy(field: PartialPropertyIterableProperty<T>? = nil, ascending: Bool? = nil) -> SortPart<T> { return SortPart(field: field ?? self.field, ascending: ascending ?? self.ascending) }
    
    public convenience init(field: PropertyIterableProperty<T, Any?>, ascending: Bool = true) {
        self.init(field: field, ascending: ascending)
    }
}

public func getListComparator<T : Codable & Hashable>(_ this: Array<SortPart<T>>) -> TypedComparator<T>? {
    if this.isEmpty { return nil }
    return makeComparator(function: { (a, b) -> Int in
        for part in (this){
            let result = part.field.compare(a, b).rawValue
            if result != 0 { return part.ascending ? result : (-result) }
        }
        return 0
    } as (T, T)->Int)
}

