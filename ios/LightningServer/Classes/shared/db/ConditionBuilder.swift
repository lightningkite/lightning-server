// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class CMBuilder<From : Codable & Hashable, To : Codable & Hashable> {
    public var mapCondition: (Condition<To>) -> Condition<From>
    public var mapModification: (Modification<To>) -> Modification<From>
    public init(mapCondition: @escaping (Condition<To>) -> Condition<From>, mapModification: @escaping (Modification<To>) -> Modification<From>) {
        self.mapCondition = mapCondition
        self.mapModification = mapModification
        //Necessary properties should be initialized now
    }
}

public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func toCMBuilder() -> CMBuilder<K, V> {
        return CMBuilder(mapCondition: { (it: Condition<V>) -> Condition<K> in self.mapCondition(it) }, mapModification: { (it: Modification<V>) -> Modification<K> in self.mapModification(it) });
    }
}

public func path<T : Codable & Hashable>() -> DataClassPath<T, T> {
    return DataClassPathSelf();
}

public func condition<T : Codable & Hashable>(setup: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<T> {
    return (setup)((path() as DataClassPath<T, T>));
}

public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    var always: Condition<V> {
        get { return ConditionAlways() }
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    var never: Condition<V> {
        get { return ConditionNever() }
    }
}

public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func eq(_ value: V) -> Condition<K> {
        return self.mapCondition(ConditionEqual(value));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func neq(_ value: V) -> Condition<K> {
        return self.mapCondition(ConditionNotEqual(value));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func ne(_ value: V) -> Condition<K> {
        return self.mapCondition(ConditionNotEqual(value));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func inside(values: Set<V>) -> Condition<K> {
        return self.mapCondition(ConditionInside(values: Array(values)));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func inside(values: Array<V>) -> Condition<K> {
        return self.mapCondition(ConditionInside(values: values));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func nin(values: Set<V>) -> Condition<K> {
        return self.mapCondition(ConditionNotInside(values: Array(values)));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func nin(values: Array<V>) -> Condition<K> {
        return self.mapCondition(ConditionNotInside(values: values));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func notIn(values: Set<V>) -> Condition<K> {
        return self.mapCondition(ConditionNotInside(values: Array(values)));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func notIn(values: Array<V>) -> Condition<K> {
        return self.mapCondition(ConditionNotInside(values: values));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable & Comparable {
    func gt(_ value: V) -> Condition<K> {
        return self.mapCondition(ConditionGreaterThan(value));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable & Comparable {
    func lt(_ value: V) -> Condition<K> {
        return self.mapCondition(ConditionLessThan(value));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable & Comparable {
    func gte(_ value: V) -> Condition<K> {
        return self.mapCondition(ConditionGreaterThanOrEqual(value));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable & Comparable {
    func lte(_ value: V) -> Condition<K> {
        return self.mapCondition(ConditionLessThanOrEqual(value));
    }
}
public extension DataClassPath where K : Codable & Hashable, V == Int {
    func allClear(mask: Int) -> Condition<K> {
        return self.mapCondition(ConditionIntBitsClear(mask: mask));
    }
}
public extension DataClassPath where K : Codable & Hashable, V == Int {
    func allSet(mask: Int) -> Condition<K> {
        return self.mapCondition(ConditionIntBitsSet(mask: mask));
    }
}
public extension DataClassPath where K : Codable & Hashable, V == Int {
    func anyClear(mask: Int) -> Condition<K> {
        return self.mapCondition(ConditionIntBitsAnyClear(mask: mask));
    }
}
public extension DataClassPath where K : Codable & Hashable, V == Int {
    func anySet(mask: Int) -> Condition<K> {
        return self.mapCondition(ConditionIntBitsAnySet(mask: mask));
    }
}
public extension DataClassPath where K : Codable & Hashable, V == String {
    func contains(_ value: String) -> Condition<K> {
        return self.mapCondition(ConditionStringContains(value, ignoreCase: true));
    }
}
public extension DataClassPath where K : Codable & Hashable, V == String {
    func contains(_ value: String, ignoreCase: Bool) -> Condition<K> {
        return self.mapCondition(ConditionStringContains(value, ignoreCase: ignoreCase));
    }
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func fullTextSearch(_ value: String, ignoreCase: Bool) -> Condition<K> {
        return self.mapCondition(ConditionFullTextSearch(value, ignoreCase: ignoreCase));
    }
}
public func xDataClassPathAll<K : Codable & Hashable, T : Codable & Hashable>(_ this: DataClassPath<K, Array<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionListAllElements((condition)((path() as DataClassPath<T, T>))));
}
public func xDataClassPathAny<K : Codable & Hashable, T : Codable & Hashable>(_ this: DataClassPath<K, Array<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionListAnyElements((condition)((path() as DataClassPath<T, T>))));
}
public func xDataClassPathSizesEquals<K : Codable & Hashable, T : Codable & Hashable>(_ this: DataClassPath<K, Array<T>>, count: Int) -> Condition<K> {
    return this.mapCondition(ConditionListSizesEquals(count: count));
}
public func xDataClassPathAll<K : Codable & Hashable, T : Codable & Hashable>(_ this: DataClassPath<K, Set<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionSetAllElements((condition)((path() as DataClassPath<T, T>))));
}
public func xDataClassPathAny<K : Codable & Hashable, T : Codable & Hashable>(_ this: DataClassPath<K, Set<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionSetAnyElements((condition)((path() as DataClassPath<T, T>))));
}
public func xDataClassPathSizesEquals<K : Codable & Hashable, T : Codable & Hashable>(_ this: DataClassPath<K, Set<T>>, count: Int) -> Condition<K> {
    return this.mapCondition(ConditionSetSizesEquals(count: count));
}
public func xDataClassPathContainsKey<K : Codable & Hashable, T : Codable & Hashable>(_ this: DataClassPath<K, Dictionary<String, T>>, key: String) -> Condition<K> {
    return this.mapCondition(ConditionExists(key: key));
}
public extension DataClassPath where K : Codable & Hashable, V : Codable & Hashable {
    func condition(make: @escaping (DataClassPath<V, V>) -> Condition<V>) -> Condition<K> {
        return self.mapCondition(make((path() as DataClassPath<V, V>)));
    }
}

//////////////

public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    var always: Condition<To> {
        get { return ConditionAlways() }
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    var never: Condition<To> {
        get { return ConditionNever() }
    }
}

public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func eq(_ value: To) -> Condition<From> {
        return self.mapCondition(ConditionEqual(value));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func neq(_ value: To) -> Condition<From> {
        return self.mapCondition(ConditionNotEqual(value));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func ne(_ value: To) -> Condition<From> {
        return self.mapCondition(ConditionNotEqual(value));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func inside(values: Set<To>) -> Condition<From> {
        return self.mapCondition(ConditionInside(values: Array(values)));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func inside(values: Array<To>) -> Condition<From> {
        return self.mapCondition(ConditionInside(values: values));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func nin(values: Set<To>) -> Condition<From> {
        return self.mapCondition(ConditionNotInside(values: Array(values)));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func nin(values: Array<To>) -> Condition<From> {
        return self.mapCondition(ConditionNotInside(values: values));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func notIn(values: Set<To>) -> Condition<From> {
        return self.mapCondition(ConditionNotInside(values: Array(values)));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func notIn(values: Array<To>) -> Condition<From> {
        return self.mapCondition(ConditionNotInside(values: values));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable & Comparable {
    func gt(_ value: To) -> Condition<From> {
        return self.mapCondition(ConditionGreaterThan(value));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable & Comparable {
    func lt(_ value: To) -> Condition<From> {
        return self.mapCondition(ConditionLessThan(value));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable & Comparable {
    func gte(_ value: To) -> Condition<From> {
        return self.mapCondition(ConditionGreaterThanOrEqual(value));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable & Comparable {
    func lte(_ value: To) -> Condition<From> {
        return self.mapCondition(ConditionLessThanOrEqual(value));
    }
}
public extension CMBuilder where From : Codable & Hashable, To == Int {
    func allClear(mask: Int) -> Condition<From> {
        return self.mapCondition(ConditionIntBitsClear(mask: mask));
    }
}
public extension CMBuilder where From : Codable & Hashable, To == Int {
    func allSet(mask: Int) -> Condition<From> {
        return self.mapCondition(ConditionIntBitsSet(mask: mask));
    }
}
public extension CMBuilder where From : Codable & Hashable, To == Int {
    func anyClear(mask: Int) -> Condition<From> {
        return self.mapCondition(ConditionIntBitsAnyClear(mask: mask));
    }
}
public extension CMBuilder where From : Codable & Hashable, To == Int {
    func anySet(mask: Int) -> Condition<From> {
        return self.mapCondition(ConditionIntBitsAnySet(mask: mask));
    }
}
public extension CMBuilder where From : Codable & Hashable, To == String {
    func contains(_ value: String) -> Condition<From> {
        return self.mapCondition(ConditionStringContains(value, ignoreCase: true));
    }
}
public extension CMBuilder where From : Codable & Hashable, To == String {
    func contains(_ value: String, ignoreCase: Bool) -> Condition<From> {
        return self.mapCondition(ConditionStringContains(value, ignoreCase: ignoreCase));
    }
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func fullTextSearch(_ value: String, ignoreCase: Bool) -> Condition<From> {
        return self.mapCondition(ConditionFullTextSearch(value, ignoreCase: ignoreCase));
    }
}
public func xCMBuilderAll<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Array<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionListAllElements((condition)((path() as DataClassPath<T, T>))));
}
public func xCMBuilderAny<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Array<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionListAnyElements((condition)((path() as DataClassPath<T, T>))));
}
public func xCMBuilderSizesEquals<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Array<T>>, count: Int) -> Condition<K> {
    return this.mapCondition(ConditionListSizesEquals(count: count));
}
public func xCMBuilderAll<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Set<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionSetAllElements((condition)((path() as DataClassPath<T, T>))));
}
public func xCMBuilderAny<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Set<T>>, condition: @escaping (DataClassPath<T, T>) -> Condition<T>) -> Condition<K> {
    return this.mapCondition(ConditionSetAnyElements((condition)((path() as DataClassPath<T, T>))));
}
public func xCMBuilderSizesEquals<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Set<T>>, count: Int) -> Condition<K> {
    return this.mapCondition(ConditionSetSizesEquals(count: count));
}
public func xCMBuilderContainsKey<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Dictionary<String, T>>, key: String) -> Condition<K> {
    return this.mapCondition(ConditionExists(key: key));
}
public extension CMBuilder where From : Codable & Hashable, To : Codable & Hashable {
    func condition(make: @escaping (DataClassPath<To, To>) -> Condition<To>) -> Condition<From> {
        return self.mapCondition(make((path() as DataClassPath<To, To>)));
    }
}


//////////////

public func getCMBuilderNotNull<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, T?>) -> CMBuilder<K, T> {
    return (CMBuilder(mapCondition: { (it) -> Condition<K> in this.mapCondition(ConditionIfNotNull(it)) } as (Condition<T>) -> Condition<K>, mapModification: { (it) -> Modification<K> in this.mapModification(ModificationIfNotNull(it)) } as (Modification<T>) -> Modification<K>) as CMBuilder<K, T>);
}


public func xCMBuilderGet<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Dictionary<String, T>>, key: String) -> CMBuilder<K, T> {
    return (CMBuilder<K, T>(mapCondition: { (it) -> Condition<K> in this.mapCondition(ConditionOnKey(key: key, condition: it)) } as (Condition<T>) -> Condition<K>, mapModification: { (it) -> Modification<K> in this.mapModification(ModificationModifyByKey(dictionaryOf(Pair(key, it)))) } as (Modification<T>) -> Modification<K>) as CMBuilder<K, T>);
}

public func getCMBuilderAll<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Array<T>>) -> CMBuilder<K, T> {
    return (CMBuilder(mapCondition: { (it) -> Condition<K> in this.mapCondition(ConditionListAllElements(it)) } as (Condition<T>) -> Condition<K>, mapModification: { (it) -> Modification<K> in this.mapModification(ModificationListPerElement(condition: ConditionAlways(), modification: it)) } as (Modification<T>) -> Modification<K>) as CMBuilder<K, T>);
}


public func getCMBuilderAll<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Set<T>>) -> CMBuilder<K, T> {
    return (CMBuilder(mapCondition: { (it) -> Condition<K> in this.mapCondition(ConditionSetAllElements(it)) } as (Condition<T>) -> Condition<K>, mapModification: { (it) -> Modification<K> in this.mapModification(ModificationSetPerElement(condition: ConditionAlways(), modification: it)) } as (Modification<T>) -> Modification<K>) as CMBuilder<K, T>);
}


public func getCMBuilderAny<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Array<T>>) -> CMBuilder<K, T> {
    return (CMBuilder(mapCondition: { (it) -> Condition<K> in this.mapCondition(ConditionListAnyElements(it)) } as (Condition<T>) -> Condition<K>, mapModification: { (it) -> Modification<K> in this.mapModification(ModificationListPerElement(condition: ConditionAlways(), modification: it)) } as (Modification<T>) -> Modification<K>) as CMBuilder<K, T>);
}


public func getCMBuilderAny<K : Codable & Hashable, T : Codable & Hashable>(_ this: CMBuilder<K, Set<T>>) -> CMBuilder<K, T> {
    return (CMBuilder(mapCondition: { (it) -> Condition<K> in this.mapCondition(ConditionSetAnyElements(it)) } as (Condition<T>) -> Condition<K>, mapModification: { (it) -> Modification<K> in this.mapModification(ModificationSetPerElement(condition: ConditionAlways(), modification: it)) } as (Modification<T>) -> Modification<K>) as CMBuilder<K, T>);
}


