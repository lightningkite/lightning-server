// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public enum Aggregate: KotlinEnum, Codable, Hashable, Comparable {
    case Sum
    case Average
    case StandardDeviationSample
    case StandardDeviationPopulation
    
    public static let caseNames = ["Sum", "Average", "StandardDeviationSample", "StandardDeviationPopulation"]
}


public extension Aggregate {
    func aggregator() -> Aggregator {
        return run { () -> Aggregator in
            switch self {
                case Aggregate.Sum:
                return SumAggregator()
                break
                case Aggregate.Average:
                return AverageAggregator()
                break
                case Aggregate.StandardDeviationSample:
                return StandardDeviationSampleAggregator()
                break
                case Aggregate.StandardDeviationPopulation:
                return StandardDeviationPopulationAggregator()
                break
                default: break
            }
            
        };
    }
}

public protocol Aggregator: AnyObject {
    
    func consume(_ value: Double) -> Void
    func complete() -> Double?
}


public final class SumAggregator : Aggregator {
    public init() {
        self.current = 0.0
        self.anyFound = false
        //Necessary properties should be initialized now
    }
    
    public var current: Double
    public var anyFound: Bool
    public func consume(_ value: Double) -> Void {
        self.anyFound = true
        self.current = self.current + value
    }
    public func complete() -> Double? {
        return self.anyFound ? self.current : nil;
    }
}
public final class AverageAggregator : Aggregator {
    public init() {
        self.count = 0
        self.current = 0.0
        //Necessary properties should be initialized now
    }
    
    public var count: Int
    public var current: Double
    public func consume(_ value: Double) -> Void {
        self.count += 1
        self.current = self.current + (value - self.current) / Double(self.count)
    }
    public func complete() -> Double? {
        return self.count == 0 ? nil : self.current;
    }
}
public final class StandardDeviationSampleAggregator : Aggregator {
    public init() {
        self.count = 0
        self.mean = 0.0
        self.m2 = 0.0
        //Necessary properties should be initialized now
    }
    
    public var count: Int
    public var mean: Double
    public var m2: Double
    public func consume(_ value: Double) -> Void {
        self.count += 1
        let delta1 = value - self.mean
        self.mean = self.mean + (delta1) / Double(self.count)
        let delta2 = value - self.mean
        self.m2 = self.m2 + delta1 * delta2
    }
    public func complete() -> Double? {
        return self.count < 2 ? nil : sqrt(self.m2 / (Double(self.count) - 1));
    }
}
public final class StandardDeviationPopulationAggregator : Aggregator {
    public init() {
        self.count = 0
        self.mean = 0.0
        self.m2 = 0.0
        //Necessary properties should be initialized now
    }
    
    public var count: Int
    public var mean: Double
    public var m2: Double
    public func consume(_ value: Double) -> Void {
        self.count += 1
        let delta1 = value - self.mean
        self.mean = self.mean + (delta1) / Double(self.count)
        let delta2 = value - self.mean
        self.m2 = self.m2 + delta1 * delta2
    }
    public func complete() -> Double? {
        return self.count == 0 ? nil : sqrt(self.m2 / Double(self.count));
    }
}

public extension Sequence where Element == Double {
    func aggregate(_ aggregate: Aggregate) -> Double? {
        let aggregator = aggregate.aggregator()
        for item in (self){
            aggregator.consume(item)
        }
        return aggregator.complete()
    }
}

