// Package: com.lightningkite.lightningserver.files
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class UploadForNextRequest : HasId, CustomStringConvertible, Hashable, Codable {
    public typealias ID = UUID
    public var _id: UUID
    public var file: String
    public var expires: Date
    public init(_id: UUID = UUID.randomUUID(), file: String, expires: Date = Date().addingTimeInterval(TimeInterval(15 * 60))) {
        self._id = _id
        self.file = file
        self.expires = expires
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            _id: values.contains(._id) ? try values.decode(UUID.self, forKey: ._id) : UUID.randomUUID(),
            file: try values.decode(String.self, forKey: .file),
            expires: values.contains(.expires) ? try values.decode(Date.self, forKey: .expires) : Date().addingTimeInterval(TimeInterval(15 * 60))
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case _id = "_id"
        case file = "file"
        case expires = "expires"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._id, forKey: ._id)
        try container.encode(self.file, forKey: .file)
        try container.encode(self.expires, forKey: .expires)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(_id)
        hasher.combine(file)
        hasher.combine(expires)
        
    }
    public static func == (lhs: UploadForNextRequest, rhs: UploadForNextRequest) -> Bool { return lhs._id == rhs._id && lhs.file == rhs.file && lhs.expires == rhs.expires }
    public var description: String { return "UploadForNextRequest(_id=\(String(kotlin: self._id)), file=\(String(kotlin: self.file)), expires=\(String(kotlin: self.expires)))" }
    public func copy(_id: UUID? = nil, file: String? = nil, expires: Date? = nil) -> UploadForNextRequest { return UploadForNextRequest(_id: _id ?? self._id, file: file ?? self.file, expires: expires ?? self.expires) }
}

public final class UploadInformation : CustomStringConvertible, Hashable, Codable {
    public var uploadUrl: String
    public var futureCallToken: String
    public init(uploadUrl: String, futureCallToken: String) {
        self.uploadUrl = uploadUrl
        self.futureCallToken = futureCallToken
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            uploadUrl: try values.decode(String.self, forKey: .uploadUrl),
            futureCallToken: try values.decode(String.self, forKey: .futureCallToken)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case uploadUrl = "uploadUrl"
        case futureCallToken = "futureCallToken"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.uploadUrl, forKey: .uploadUrl)
        try container.encode(self.futureCallToken, forKey: .futureCallToken)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(uploadUrl)
        hasher.combine(futureCallToken)
        
    }
    public static func == (lhs: UploadInformation, rhs: UploadInformation) -> Bool { return lhs.uploadUrl == rhs.uploadUrl && lhs.futureCallToken == rhs.futureCallToken }
    public var description: String { return "UploadInformation(uploadUrl=\(String(kotlin: self.uploadUrl)), futureCallToken=\(String(kotlin: self.futureCallToken)))" }
    public func copy(uploadUrl: String? = nil, futureCallToken: String? = nil) -> UploadInformation { return UploadInformation(uploadUrl: uploadUrl ?? self.uploadUrl, futureCallToken: futureCallToken ?? self.futureCallToken) }
}
