// Package: com.lightningkite.lightningserver.serverhealth
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class HealthStatus : CustomStringConvertible, Hashable, Codable {
    public var level: Level
    public var checkedAt: Date
    public var additionalMessage: String?
    public init(_ level: Level, checkedAt: Date = Date(), additionalMessage: String? = nil) {
        self.level = level
        self.checkedAt = checkedAt
        self.additionalMessage = additionalMessage
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            try values.decode(Level.self, forKey: .level),
            checkedAt: values.contains(.checkedAt) ? try values.decode(Date.self, forKey: .checkedAt) : Date(),
            additionalMessage: values.contains(.additionalMessage) ? try values.decode(String?.self, forKey: .additionalMessage) : nil
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case level = "level"
        case checkedAt = "checkedAt"
        case additionalMessage = "additionalMessage"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.level, forKey: .level)
        try container.encode(self.checkedAt, forKey: .checkedAt)
        try container.encodeIfPresent(self.additionalMessage, forKey: .additionalMessage)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(level)
        hasher.combine(checkedAt)
        hasher.combine(additionalMessage)
        
    }
    public static func == (lhs: HealthStatus, rhs: HealthStatus) -> Bool { return lhs.level == rhs.level && lhs.checkedAt == rhs.checkedAt && lhs.additionalMessage == rhs.additionalMessage }
    public var description: String { return "HealthStatus(level=\(String(kotlin: self.level)), checkedAt=\(String(kotlin: self.checkedAt)), additionalMessage=\(String(kotlin: self.additionalMessage)))" }
    public func copy(_ level: Level? = nil, checkedAt: Date? = nil, additionalMessage: String?? = .some(nil)) -> HealthStatus { return HealthStatus(level ?? self.level, checkedAt: checkedAt ?? self.checkedAt, additionalMessage: invertOptional(additionalMessage) ?? self.additionalMessage) }
    
    public enum Level: KotlinEnum, Codable, Hashable, Comparable {
        case OK
        case WARNING
        case URGENT
        case ERROR
        
        public static let caseNames = ["OK", "WARNING", "URGENT", "ERROR"]
        private static let colorValues: Dictionary<Level, String> = [
                .OK: "green",
                .WARNING: "yellow",
                .URGENT: "orange",
                .ERROR: "red"
        ]
        public var color: String {
            return Level.colorValues[self] ?? Level.colorValues[.OK]!
        }
    }
    
}

public final class ServerHealth : CustomStringConvertible, Hashable, Codable {
    public var serverId: String
    public var version: String
    public var memory: Memory
    public var features: Dictionary<String, HealthStatus>
    public var loadAverageCpu: Double
    public init(serverId: String, version: String, memory: Memory, features: Dictionary<String, HealthStatus>, loadAverageCpu: Double) {
        self.serverId = serverId
        self.version = version
        self.memory = memory
        self.features = features
        self.loadAverageCpu = loadAverageCpu
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            serverId: try values.decode(String.self, forKey: .serverId),
            version: try values.decode(String.self, forKey: .version),
            memory: try values.decode(Memory.self, forKey: .memory),
            features: try values.decode(Dictionary<String, HealthStatus>.self, forKey: .features),
            loadAverageCpu: try values.decode(Double.self, forKey: .loadAverageCpu)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case serverId = "serverId"
        case version = "version"
        case memory = "memory"
        case features = "features"
        case loadAverageCpu = "loadAverageCpu"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.serverId, forKey: .serverId)
        try container.encode(self.version, forKey: .version)
        try container.encode(self.memory, forKey: .memory)
        try container.encode(self.features, forKey: .features)
        try container.encode(self.loadAverageCpu, forKey: .loadAverageCpu)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(serverId)
        hasher.combine(version)
        hasher.combine(memory)
        hasher.combine(features)
        hasher.combine(loadAverageCpu)
        
    }
    public static func == (lhs: ServerHealth, rhs: ServerHealth) -> Bool { return lhs.serverId == rhs.serverId && lhs.version == rhs.version && lhs.memory == rhs.memory && lhs.features == rhs.features && lhs.loadAverageCpu == rhs.loadAverageCpu }
    public var description: String { return "ServerHealth(serverId=\(String(kotlin: self.serverId)), version=\(String(kotlin: self.version)), memory=\(String(kotlin: self.memory)), features=\(String(kotlin: self.features)), loadAverageCpu=\(String(kotlin: self.loadAverageCpu)))" }
    public func copy(serverId: String? = nil, version: String? = nil, memory: Memory? = nil, features: Dictionary<String, HealthStatus>? = nil, loadAverageCpu: Double? = nil) -> ServerHealth { return ServerHealth(serverId: serverId ?? self.serverId, version: version ?? self.version, memory: memory ?? self.memory, features: features ?? self.features, loadAverageCpu: loadAverageCpu ?? self.loadAverageCpu) }
    
    
    public final class Memory : CustomStringConvertible, Hashable, Codable {
        public var max: Int
        public var total: Int
        public var free: Int
        public var systemAllocated: Int
        public var usage: Float
        public init(max: Int, total: Int, free: Int, systemAllocated: Int, usage: Float) {
            self.max = max
            self.total = total
            self.free = free
            self.systemAllocated = systemAllocated
            self.usage = usage
            //Necessary properties should be initialized now
        }
        convenience required public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.init(
                max: try values.decode(Int.self, forKey: .max),
                total: try values.decode(Int.self, forKey: .total),
                free: try values.decode(Int.self, forKey: .free),
                systemAllocated: try values.decode(Int.self, forKey: .systemAllocated),
                usage: try values.decode(Float.self, forKey: .usage)
            )
        }
        
        enum CodingKeys: String, CodingKey {
            case max = "max"
            case total = "total"
            case free = "free"
            case systemAllocated = "systemAllocated"
            case usage = "usage"
        }
        
        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.max, forKey: .max)
            try container.encode(self.total, forKey: .total)
            try container.encode(self.free, forKey: .free)
            try container.encode(self.systemAllocated, forKey: .systemAllocated)
            try container.encode(self.usage, forKey: .usage)
        }
        
        public func hash(into hasher: inout Hasher) {
            hasher.combine(max)
            hasher.combine(total)
            hasher.combine(free)
            hasher.combine(systemAllocated)
            hasher.combine(usage)
            
        }
        public static func == (lhs: Memory, rhs: Memory) -> Bool { return lhs.max == rhs.max && lhs.total == rhs.total && lhs.free == rhs.free && lhs.systemAllocated == rhs.systemAllocated && lhs.usage == rhs.usage }
        public var description: String { return "Memory(max=\(String(kotlin: self.max)), total=\(String(kotlin: self.total)), free=\(String(kotlin: self.free)), systemAllocated=\(String(kotlin: self.systemAllocated)), usage=\(String(kotlin: self.usage)))" }
        public func copy(max: Int? = nil, total: Int? = nil, free: Int? = nil, systemAllocated: Int? = nil, usage: Float? = nil) -> Memory { return Memory(max: max ?? self.max, total: total ?? self.total, free: free ?? self.free, systemAllocated: systemAllocated ?? self.systemAllocated, usage: usage ?? self.usage) }
        
    }
}
