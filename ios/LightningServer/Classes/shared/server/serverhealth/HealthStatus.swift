// Package: com.lightningkite.lightningserver.serverhealth
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class HealthStatus : CustomStringConvertible, Hashable, Codable {
    public var level: Level
    public var checkedAt: Date
    public var additionalMessage: String?
    public init(_ level: Level, checkedAt: Date = Date(), additionalMessage: String? = nil) {
        self.level = level
        self.checkedAt = checkedAt
        self.additionalMessage = additionalMessage
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            try values.decode(Level.self, forKey: .level),
            checkedAt: values.contains(.checkedAt) ? try values.decode(Date.self, forKey: .checkedAt) : Date(),
            additionalMessage: values.contains(.additionalMessage) ? try values.decode(String?.self, forKey: .additionalMessage) : nil
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case level = "level"
        case checkedAt = "checkedAt"
        case additionalMessage = "additionalMessage"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.level, forKey: .level)
        try container.encode(self.checkedAt, forKey: .checkedAt)
        try container.encodeIfPresent(self.additionalMessage, forKey: .additionalMessage)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(level)
        hasher.combine(checkedAt)
        hasher.combine(additionalMessage)
        
    }
    public static func == (lhs: HealthStatus, rhs: HealthStatus) -> Bool { return lhs.level == rhs.level && lhs.checkedAt == rhs.checkedAt && lhs.additionalMessage == rhs.additionalMessage }
    public var description: String { return "HealthStatus(level=\(String(kotlin: self.level)), checkedAt=\(String(kotlin: self.checkedAt)), additionalMessage=\(String(kotlin: self.additionalMessage)))" }
    public func copy(_ level: Level? = nil, checkedAt: Date? = nil, additionalMessage: String?? = .some(nil)) -> HealthStatus { return HealthStatus(level ?? self.level, checkedAt: checkedAt ?? self.checkedAt, additionalMessage: invertOptional(additionalMessage) ?? self.additionalMessage) }
    
    public enum Level: KotlinEnum, Codable, Hashable, Comparable {
        case OK
        case WARNING
        case URGENT
        case ERROR
        
        public static let caseNames = ["OK", "WARNING", "URGENT", "ERROR"]
        private static let colorValues: Dictionary<Level, String> = [
                .OK: "green",
                .WARNING: "yellow",
                .URGENT: "orange",
                .ERROR: "red"
        ]
        public var color: String {
            return Level.colorValues[self] ?? Level.colorValues[.OK]!
        }
    }
    
}

public final class ServerHealth : CustomStringConvertible, Hashable, Codable {
    public var serverId: String
    public var version: String
    public var memory: Memory
    public var features: Dictionary<String, HealthStatus>
    public var loadAverageCpu: Double
    public init(serverId: String, version: String, memory: Memory, features: Dictionary<String, HealthStatus>, loadAverageCpu: Double) {
        self.serverId = serverId
        self.version = version
        self.memory = memory
        self.features = features
        self.loadAverageCpu = loadAverageCpu
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            serverId: try values.decode(String.self, forKey: .serverId),
            version: try values.decode(String.self, forKey: .version),
            memory: try values.decode(Memory.self, forKey: .memory),
            features: try values.decode(Dictionary<String, HealthStatus>.self, forKey: .features),
            loadAverageCpu: try values.decode(Double.self, forKey: .loadAverageCpu)
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case serverId = "serverId"
        case version = "version"
        case memory = "memory"
        case features = "features"
        case loadAverageCpu = "loadAverageCpu"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.serverId, forKey: .serverId)
        try container.encode(self.version, forKey: .version)
        try container.encode(self.memory, forKey: .memory)
        try container.encode(self.features, forKey: .features)
        try container.encode(self.loadAverageCpu, forKey: .loadAverageCpu)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(serverId)
        hasher.combine(version)
        hasher.combine(memory)
        hasher.combine(features)
        hasher.combine(loadAverageCpu)
        
    }
    public static func == (lhs: ServerHealth, rhs: ServerHealth) -> Bool { return lhs.serverId == rhs.serverId && lhs.version == rhs.version && lhs.memory == rhs.memory && lhs.features == rhs.features && lhs.loadAverageCpu == rhs.loadAverageCpu }
    public var description: String { return "ServerHealth(serverId=\(String(kotlin: self.serverId)), version=\(String(kotlin: self.version)), memory=\(String(kotlin: self.memory)), features=\(String(kotlin: self.features)), loadAverageCpu=\(String(kotlin: self.loadAverageCpu)))" }
    public func copy(serverId: String? = nil, version: String? = nil, memory: Memory? = nil, features: Dictionary<String, HealthStatus>? = nil, loadAverageCpu: Double? = nil) -> ServerHealth { return ServerHealth(serverId: serverId ?? self.serverId, version: version ?? self.version, memory: memory ?? self.memory, features: features ?? self.features, loadAverageCpu: loadAverageCpu ?? self.loadAverageCpu) }
    
    
    public final class Memory : CustomStringConvertible, Hashable, Codable {
        public var maxMem: Int
        public var totalMemory: Int
        public var freeMemory: Int
        public var systemAllocated: Int
        public var memUsagePercent: Float
        public init(maxMem: Int, totalMemory: Int, freeMemory: Int, systemAllocated: Int, memUsagePercent: Float) {
            self.maxMem = maxMem
            self.totalMemory = totalMemory
            self.freeMemory = freeMemory
            self.systemAllocated = systemAllocated
            self.memUsagePercent = memUsagePercent
            //Necessary properties should be initialized now
        }
        convenience required public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.init(
                maxMem: try values.decode(Int.self, forKey: .maxMem),
                totalMemory: try values.decode(Int.self, forKey: .totalMemory),
                freeMemory: try values.decode(Int.self, forKey: .freeMemory),
                systemAllocated: try values.decode(Int.self, forKey: .systemAllocated),
                memUsagePercent: try values.decode(Float.self, forKey: .memUsagePercent)
            )
        }
        
        enum CodingKeys: String, CodingKey {
            case maxMem = "maxMem"
            case totalMemory = "totalMemory"
            case freeMemory = "freeMemory"
            case systemAllocated = "systemAllocated"
            case memUsagePercent = "memUsagePercent"
        }
        
        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.maxMem, forKey: .maxMem)
            try container.encode(self.totalMemory, forKey: .totalMemory)
            try container.encode(self.freeMemory, forKey: .freeMemory)
            try container.encode(self.systemAllocated, forKey: .systemAllocated)
            try container.encode(self.memUsagePercent, forKey: .memUsagePercent)
        }
        
        public func hash(into hasher: inout Hasher) {
            hasher.combine(maxMem)
            hasher.combine(totalMemory)
            hasher.combine(freeMemory)
            hasher.combine(systemAllocated)
            hasher.combine(memUsagePercent)
            
        }
        public static func == (lhs: Memory, rhs: Memory) -> Bool { return lhs.maxMem == rhs.maxMem && lhs.totalMemory == rhs.totalMemory && lhs.freeMemory == rhs.freeMemory && lhs.systemAllocated == rhs.systemAllocated && lhs.memUsagePercent == rhs.memUsagePercent }
        public var description: String { return "Memory(maxMem=\(String(kotlin: self.maxMem)), totalMemory=\(String(kotlin: self.totalMemory)), freeMemory=\(String(kotlin: self.freeMemory)), systemAllocated=\(String(kotlin: self.systemAllocated)), memUsagePercent=\(String(kotlin: self.memUsagePercent)))" }
        public func copy(maxMem: Int? = nil, totalMemory: Int? = nil, freeMemory: Int? = nil, systemAllocated: Int? = nil, memUsagePercent: Float? = nil) -> Memory { return Memory(maxMem: maxMem ?? self.maxMem, totalMemory: totalMemory ?? self.totalMemory, freeMemory: freeMemory ?? self.freeMemory, systemAllocated: systemAllocated ?? self.systemAllocated, memUsagePercent: memUsagePercent ?? self.memUsagePercent) }
        
    }
}
