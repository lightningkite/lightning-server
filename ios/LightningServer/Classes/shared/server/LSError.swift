// Package: com.lightningkite.lightningserver
// Generated by Khrysalis - this file will be overwritten.
import KhrysalisRuntime
import Foundation

public final class LSError : CustomStringConvertible, Hashable, Codable {
    public var http: Int
    public var detail: String
    public var message: String
    public var data: String
    public init(http: Int, detail: String = "", message: String = "", data: String = "") {
        self.http = http
        self.detail = detail
        self.message = message
        self.data = data
        //Necessary properties should be initialized now
    }
    convenience required public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.init(
            http: try values.decode(Int.self, forKey: .http),
            detail: values.contains(.detail) ? try values.decode(String.self, forKey: .detail) : "",
            message: values.contains(.message) ? try values.decode(String.self, forKey: .message) : "",
            data: values.contains(.data) ? try values.decode(String.self, forKey: .data) : ""
        )
    }
    
    enum CodingKeys: String, CodingKey {
        case http = "http"
        case detail = "detail"
        case message = "message"
        case data = "data"
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.http, forKey: .http)
        try container.encode(self.detail, forKey: .detail)
        try container.encode(self.message, forKey: .message)
        try container.encode(self.data, forKey: .data)
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(http)
        hasher.combine(detail)
        hasher.combine(message)
        hasher.combine(data)
        
    }
    public static func == (lhs: LSError, rhs: LSError) -> Bool { return lhs.http == rhs.http && lhs.detail == rhs.detail && lhs.message == rhs.message && lhs.data == rhs.data }
    public var description: String { return "LSError(http=\(String(kotlin: self.http)), detail=\(String(kotlin: self.detail)), message=\(String(kotlin: self.message)), data=\(String(kotlin: self.data)))" }
    public func copy(http: Int? = nil, detail: String? = nil, message: String? = nil, data: String? = nil) -> LSError { return LSError(http: http ?? self.http, detail: detail ?? self.detail, message: message ?? self.message, data: data ?? self.data) }
    
}

