"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multiplexedSocketRaw = exports.multiplexedSocket = exports.multiplexedSocketReified = exports.WebSocketIsh = exports.sharedSocket = exports.set_overrideWebSocketProvider = exports.get_overrideWebSocketProvider = exports.__overrideWebSocketProvider = exports.setSharedSocketShouldBeActive = exports.getSharedSocketShouldBeActive = exports._sharedSocketShouldBeActive = void 0;
// Package: com.lightningkite.lightningdb.live
// Generated by Khrysalis - this file will be overwritten.
const MultiplexMessage_1 = require("../db/MultiplexMessage");
const khrysalis_runtime_1 = require("@lightningkite/khrysalis-runtime");
const rxjs_plus_1 = require("@lightningkite/rxjs-plus");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const uuid_1 = require("uuid");
//! Declares com.lightningkite.lightningdb.live.sharedSocketShouldBeActive
exports._sharedSocketShouldBeActive = (0, rxjs_1.of)(true);
function getSharedSocketShouldBeActive() { return exports._sharedSocketShouldBeActive; }
exports.getSharedSocketShouldBeActive = getSharedSocketShouldBeActive;
function setSharedSocketShouldBeActive(value) { exports._sharedSocketShouldBeActive = value; }
exports.setSharedSocketShouldBeActive = setSharedSocketShouldBeActive;
let retryTime = 1000;
let lastRetry = 0;
//! Declares com.lightningkite.lightningdb.live._overrideWebSocketProvider
exports.__overrideWebSocketProvider = null;
function get_overrideWebSocketProvider() { return exports.__overrideWebSocketProvider; }
exports.get_overrideWebSocketProvider = get_overrideWebSocketProvider;
function set_overrideWebSocketProvider(value) { exports.__overrideWebSocketProvider = value; }
exports.set_overrideWebSocketProvider = set_overrideWebSocketProvider;
const sharedSocketCache = new Map();
//! Declares com.lightningkite.lightningdb.live.sharedSocket
function sharedSocket(url) {
    return (0, khrysalis_runtime_1.xMutableMapGetOrPut)(sharedSocketCache, url, () => (getSharedSocketShouldBeActive()
        .pipe((0, operators_1.distinctUntilChanged)())
        .pipe((0, operators_1.switchMap)((it) => {
        const shortUrl = (0, khrysalis_runtime_1.xStringSubstringBefore)(url, '?', undefined);
        return (() => {
            var _a;
            if ((!it)) {
                return rxjs_1.NEVER;
            }
            else {
                console.log(`Creating socket to ${url}`);
                return ((_a = (0, khrysalis_runtime_1.runOrNull)(get_overrideWebSocketProvider(), _ => _(url))) !== null && _a !== void 0 ? _a : rxjs_plus_1.HttpClient.INSTANCE.webSocket(url))
                    .pipe((0, operators_1.switchMap)((it) => {
                    lastRetry = Date.now();
                    //                            println("Connection to $shortUrl established, starting pings")
                    // Only have this observable until it fails
                    const pingMessages = (0, rxjs_1.interval)(30000)
                        .pipe((0, operators_1.map)((_0) => {
                        //                                        println("Sending ping to $url")
                        return it.write.next({ text: " ", binary: null });
                    })).pipe((0, operators_1.switchMap)((it) => (rxjs_1.NEVER)));
                    const timeoutAfterSeconds = it.read
                        .pipe((0, operators_1.tap)((it) => {
                        //                                    println("Got message from $shortUrl: ${it}")
                        if (Date.now() > lastRetry + 60000) {
                            retryTime = 1000;
                        }
                    }))
                        .pipe((0, operators_1.timeout)(40000))
                        .pipe((0, operators_1.switchMap)((it) => (rxjs_1.NEVER)));
                    return (0, rxjs_1.merge)((0, rxjs_1.of)(it), pingMessages, timeoutAfterSeconds);
                }))
                    .pipe((0, operators_1.tap)(undefined, (it) => {
                    console.log(`Socket to ${shortUrl} FAILED with ${it}`);
                }))
                    .pipe((0, operators_1.retryWhen)((it) => {
                    const temp = retryTime;
                    retryTime = temp * 2;
                    return it.pipe((0, operators_1.delay)(temp));
                }))
                    .pipe((0, operators_1.tap)({ unsubscribe: () => {
                        console.log(`Disconnecting socket to ${shortUrl}`);
                    } }));
            }
        })();
    }))
        .pipe((0, operators_1.publishReplay)(1))
        .pipe((0, operators_1.refCount)())));
}
exports.sharedSocket = sharedSocket;
//! Declares com.lightningkite.lightningdb.live.WebSocketIsh
class WebSocketIsh {
    constructor(messages, send) {
        this.messages = messages;
        this.send = send;
    }
}
exports.WebSocketIsh = WebSocketIsh;
//! Declares com.lightningkite.lightningdb.live.multiplexedSocket
function multiplexedSocketReified(IN, OUT, url, path, queryParams = new Map([])) {
    return multiplexedSocket(url, path, queryParams, IN, OUT);
}
exports.multiplexedSocketReified = multiplexedSocketReified;
//! Declares com.lightningkite.lightningdb.live.multiplexedSocket
function multiplexedSocket(url, path, queryParams = new Map([]), inType, outType) {
    return multiplexedSocketRaw(url, path, queryParams)
        .pipe((0, operators_1.map)((it) => (new WebSocketIsh(it.messages.pipe((0, rxjs_1.map)((it) => (rxjs_plus_1.JSON2.parse(it, inType))), (0, rxjs_1.filter)(rxjs_plus_1.isNonNull)), (m) => {
        it.send(JSON.stringify(m));
    }))));
}
exports.multiplexedSocket = multiplexedSocket;
//! Declares com.lightningkite.lightningdb.live.multiplexedSocketRaw
function multiplexedSocketRaw(url, path, queryParams = new Map([])) {
    const shortUrl = (0, khrysalis_runtime_1.xStringSubstringBefore)(url, '?', undefined);
    const channel = (0, uuid_1.v4)();
    let lastSocket = null;
    return sharedSocket(url)
        .pipe((0, operators_1.switchMap)((it) => {
        console.log(`Setting up socket to ${shortUrl} with ${path}`);
        lastSocket = it;
        const multiplexedIn = it.read.pipe((0, rxjs_1.map)((it) => {
            const text = it.text;
            if (text === null) {
                return null;
            }
            if ((0, khrysalis_runtime_1.xCharSequenceIsBlank)(text)) {
                return null;
            }
            return rxjs_plus_1.JSON2.parse(text, [MultiplexMessage_1.MultiplexMessage]);
        }), (0, rxjs_1.filter)(rxjs_plus_1.isNonNull));
        return multiplexedIn
            .pipe((0, operators_1.filter)((it) => (it.channel === channel && it.start)))
            .pipe((0, operators_1.take)(1))
            .pipe((0, operators_1.map)((_0) => {
            console.log(`Connected to channel ${channel}`);
            return new WebSocketIsh(multiplexedIn.pipe((0, rxjs_1.map)((it) => (it.channel === channel ? it.data : null)), (0, rxjs_1.filter)(rxjs_plus_1.isNonNull)), (message) => {
                console.log(`Sending ${message} to ${it}`);
                it.write.next({ text: JSON.stringify(new MultiplexMessage_1.MultiplexMessage(channel, undefined, undefined, undefined, undefined, message, undefined)), binary: null });
            });
        }))
            .pipe((0, rxjs_plus_1.doOnSubscribe)((_0) => {
            it.write.next({ text: JSON.stringify(new MultiplexMessage_1.MultiplexMessage(channel, path, queryParams, true, undefined, undefined, undefined)), binary: null });
        }));
    }))
        .pipe((0, operators_1.tap)({ unsubscribe: () => {
            var _a;
            console.log(`Disconnecting channel on socket to ${shortUrl} with ${path}`);
            const temp64 = ((_a = lastSocket === null || lastSocket === void 0 ? void 0 : lastSocket.write) !== null && _a !== void 0 ? _a : null);
            if (temp64 !== null && temp64 !== undefined) {
                temp64.next({ text: JSON.stringify(new MultiplexMessage_1.MultiplexMessage(channel, path, undefined, undefined, true, undefined, undefined)), binary: null });
            }
            ;
        } }));
}
exports.multiplexedSocketRaw = multiplexedSocketRaw;
//# sourceMappingURL=sockets.js.map