"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multiplexedSocketRaw = exports.multiplexedSocket = exports.multiplexedSocketReified = exports.WebSocketIsh = exports.sharedSocket = exports.set_overrideWebSocketProvider = exports.get_overrideWebSocketProvider = exports.__overrideWebSocketProvider = void 0;
// Package: com.lightningkite.lightningdb.live
// Generated by Khrysalis - this file will be overwritten.
const MultiplexMessage_1 = require("../db/MultiplexMessage");
const khrysalis_runtime_1 = require("@lightningkite/khrysalis-runtime");
const rxjs_plus_1 = require("@lightningkite/rxjs-plus");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const uuid_1 = require("uuid");
//! Declares com.lightningkite.lightningdb.live._overrideWebSocketProvider
exports.__overrideWebSocketProvider = null;
function get_overrideWebSocketProvider() { return exports.__overrideWebSocketProvider; }
exports.get_overrideWebSocketProvider = get_overrideWebSocketProvider;
function set_overrideWebSocketProvider(value) { exports.__overrideWebSocketProvider = value; }
exports.set_overrideWebSocketProvider = set_overrideWebSocketProvider;
const sharedSocketCache = new Map();
//! Declares com.lightningkite.lightningdb.live.sharedSocket
function sharedSocket(url) {
    return (0, khrysalis_runtime_1.xMutableMapGetOrPut)(sharedSocketCache, url, () => {
        var _a;
        const shortUrl = (0, khrysalis_runtime_1.xStringSubstringBefore)(url, '?', undefined);
        console.log(`Creating socket to ${url}`);
        return ((_a = (0, khrysalis_runtime_1.runOrNull)(get_overrideWebSocketProvider(), _ => _(url))) !== null && _a !== void 0 ? _a : rxjs_plus_1.HttpClient.INSTANCE.webSocket(url))
            .pipe((0, operators_1.switchMap)((it) => {
            console.log(`Connection to ${shortUrl} established, starting pings`);
            // Only have this observable until it fails
            const pingMessages = (0, rxjs_1.interval)(30000).pipe((0, operators_1.map)((_0) => {
                console.log(`Sending ping to ${url}`);
                return it.write.next({ text: " ", binary: null });
            })).pipe((0, operators_1.switchMap)((it) => (rxjs_1.NEVER)));
            const timeoutAfterSeconds = it.read
                .pipe((0, operators_1.tap)((it) => {
                console.log(`Got message from ${shortUrl}: ${it}`);
            }))
                .pipe((0, operators_1.timeout)(60000))
                .pipe((0, operators_1.switchMap)((it) => (rxjs_1.NEVER)));
            return (0, rxjs_1.merge)((0, rxjs_1.of)(it), pingMessages, timeoutAfterSeconds);
        }))
            .pipe((0, operators_1.tap)(undefined, (it) => {
            console.log(`Socket to ${shortUrl} FAILED with ${it}`);
        }))
            .pipe((0, operators_1.tap)(undefined, undefined, () => {
            console.log(`Disconnecting socket to ${shortUrl}`);
            sharedSocketCache.delete(url);
        }))
            .pipe((0, operators_1.publishReplay)(1))
            .pipe((0, operators_1.refCount)());
    });
}
exports.sharedSocket = sharedSocket;
//! Declares com.lightningkite.lightningdb.live.WebSocketIsh
class WebSocketIsh {
    constructor(messages, send) {
        this.messages = messages;
        this.send = send;
    }
}
exports.WebSocketIsh = WebSocketIsh;
//! Declares com.lightningkite.lightningdb.live.multiplexedSocket
function multiplexedSocketReified(IN, OUT, url, path, queryParams = new Map([])) {
    return multiplexedSocket(url, path, queryParams, IN, OUT);
}
exports.multiplexedSocketReified = multiplexedSocketReified;
//! Declares com.lightningkite.lightningdb.live.multiplexedSocket
function multiplexedSocket(url, path, queryParams = new Map([]), inType, outType) {
    return multiplexedSocketRaw(url, path, queryParams)
        .pipe((0, operators_1.map)((it) => (new WebSocketIsh(it.messages.pipe((0, rxjs_1.map)((it) => (rxjs_plus_1.JSON2.parse(it, inType))), (0, rxjs_1.filter)(rxjs_plus_1.isNonNull)), (m) => {
        it.send(JSON.stringify(m));
    }))));
}
exports.multiplexedSocket = multiplexedSocket;
//! Declares com.lightningkite.lightningdb.live.multiplexedSocketRaw
function multiplexedSocketRaw(url, path, queryParams = new Map([])) {
    const shortUrl = (0, khrysalis_runtime_1.xStringSubstringBefore)(url, '?', undefined);
    const channel = (0, uuid_1.v4)();
    let lastSocket = null;
    return sharedSocket(url)
        .pipe((0, operators_1.switchMap)((it) => {
        console.log(`Setting up socket to ${shortUrl} with ${path}`);
        lastSocket = it;
        const multiplexedIn = it.read.pipe((0, rxjs_1.map)((it) => {
            console.log(`Got raw from websocket ${it}`);
            const text = it.text;
            if (text === null) {
                return null;
            }
            if (text === "") {
                return null;
            }
            return rxjs_plus_1.JSON2.parse(text, [MultiplexMessage_1.MultiplexMessage]);
        }), (0, rxjs_1.filter)(rxjs_plus_1.isNonNull));
        return multiplexedIn
            .pipe((0, operators_1.filter)((it) => (it.channel === channel && it.start)))
            .pipe((0, operators_1.take)(1))
            .pipe((0, operators_1.map)((_0) => {
            console.log(`Connected to channel ${channel}`);
            return new WebSocketIsh(multiplexedIn.pipe((0, rxjs_1.map)((it) => (it.channel === channel ? it.data : null)), (0, rxjs_1.filter)(rxjs_plus_1.isNonNull)), (message) => {
                console.log(`Sending ${message} to ${it}`);
                it.write.next({ text: JSON.stringify(new MultiplexMessage_1.MultiplexMessage(channel, undefined, undefined, undefined, undefined, message, undefined)), binary: null });
            });
        }))
            .pipe((0, rxjs_plus_1.doOnSubscribe)((_0) => {
            it.write.next({ text: JSON.stringify(new MultiplexMessage_1.MultiplexMessage(channel, path, queryParams, true, undefined, undefined, undefined)), binary: null });
        }));
    }))
        .pipe((0, operators_1.tap)({ unsubscribe: () => {
            var _a;
            console.log(`Disconnecting channel on socket to ${shortUrl} with ${path}`);
            const temp61 = ((_a = lastSocket === null || lastSocket === void 0 ? void 0 : lastSocket.write) !== null && _a !== void 0 ? _a : null);
            if (temp61 !== null && temp61 !== undefined) {
                temp61.next({ text: JSON.stringify(new MultiplexMessage_1.MultiplexMessage(channel, path, undefined, undefined, true, undefined, undefined)), binary: null });
            }
            ;
        } }));
}
exports.multiplexedSocketRaw = multiplexedSocketRaw;
//# sourceMappingURL=sockets.js.map