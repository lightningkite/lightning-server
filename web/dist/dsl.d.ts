import { Condition } from './Condition';
import { DataClassProperty } from './DataClassProperty';
import { Modification } from './Modification';
import { Comparable } from '@lightningkite/khrysalis-runtime';
export declare function startChain<T extends any>(): KeyPath<T, T>;
export declare class KeyPath<From extends any, To extends any> {
    readonly mapCondition: ((a: Condition<To>) => Condition<From>);
    readonly mapModification: ((a: Modification<To>) => Modification<From>);
    constructor(mapCondition: ((a: Condition<To>) => Condition<From>), mapModification: ((a: Modification<To>) => Modification<From>));
    get<V extends any>(prop: DataClassProperty<To, V>): KeyPath<From, V>;
}
export declare function xKeyPathEq<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Condition<K>;
export declare function xKeyPathNeq<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Condition<K>;
export declare function xKeyPathNe<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Condition<K>;
export declare function xKeyPathInside<K extends any, T extends any>(this_: KeyPath<K, T>, values: Array<T>): Condition<K>;
export declare function xKeyPathNin<K extends any, T extends any>(this_: KeyPath<K, T>, values: Array<T>): Condition<K>;
export declare function xKeyPathNotIn<K extends any, T extends any>(this_: KeyPath<K, T>, values: Array<T>): Condition<K>;
export declare function xKeyPathGt<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Condition<K>;
export declare function xKeyPathLt<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Condition<K>;
export declare function xKeyPathGte<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Condition<K>;
export declare function xKeyPathLte<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Condition<K>;
export declare function xKeyPathAllClear<K extends any>(this_: KeyPath<K, number>, mask: number): Condition<K>;
export declare function xKeyPathAllSet<K extends any>(this_: KeyPath<K, number>, mask: number): Condition<K>;
export declare function xKeyPathAnyClear<K extends any>(this_: KeyPath<K, number>, mask: number): Condition<K>;
export declare function xKeyPathAnySet<K extends any>(this_: KeyPath<K, number>, mask: number): Condition<K>;
export declare function xKeyPathContains<K extends any>(this_: KeyPath<K, string>, value: string): Condition<K>;
export declare function xKeyPathContainsCased<K extends any>(this_: KeyPath<K, string>, value: string, ignoreCase: boolean): Condition<K>;
export declare function xKeyPathAll<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, condition: ((a: KeyPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xKeyPathAny<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, condition: ((a: KeyPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xKeyPathSizesEquals<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, count: number): Condition<K>;
export declare function xKeyPathContainsKey<K extends any, T extends any>(this_: KeyPath<K, Map<string, T>>, key: string): Condition<K>;
export declare function xKeyPathNotNullGet<K extends any, T extends any>(this_: KeyPath<K, (T | null)>): KeyPath<K, T>;
export declare function xKeyPathGet<K extends any, T extends any>(this_: KeyPath<K, Map<string, T>>, key: string): KeyPath<K, T>;
export declare function xKeyPathCondition<K extends any, T extends any>(this_: KeyPath<K, T>, make: ((a: KeyPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xKeyPathModification<K extends any, T extends any>(this_: KeyPath<K, T>, make: ((a: KeyPath<T, T>) => Modification<T>)): Modification<K>;
export declare function xKeyPathAssign<K extends any, T extends any>(this_: KeyPath<K, T>, value: T): Modification<K>;
export declare function xKeyPathCoerceAtMost<K extends any, T extends Comparable<T>>(this_: KeyPath<K, T>, value: T): Modification<K>;
export declare function xKeyPathCoerceAtLeast<K extends any, T extends Comparable<T>>(this_: KeyPath<K, T>, value: T): Modification<K>;
export declare function xKeyPathPlusNumber<K extends any, T extends number>(this_: KeyPath<K, T>, by: T): Modification<K>;
export declare function xKeyPathTimes<K extends any, T extends number>(this_: KeyPath<K, T>, by: T): Modification<K>;
export declare function xKeyPathPlusString<K extends any>(this_: KeyPath<K, string>, value: string): Modification<K>;
export declare function xKeyPathPlusItems<K extends any, T>(this_: KeyPath<K, Array<T>>, items: Array<T>): Modification<K>;
export declare function xKeyPathPlusItem<K extends any, T>(this_: KeyPath<K, Array<T>>, item: T): Modification<K>;
export declare function xKeyPathAddAll<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, items: Array<T>): Modification<K>;
export declare function xKeyPathAddUnique<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, items: Array<T>): Modification<K>;
export declare function xKeyPathRemoveAll<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, condition: ((a: KeyPath<T, T>) => Condition<T>)): Modification<K>;
export declare function xKeyPathRemoveList<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, items: Array<T>): Modification<K>;
export declare function xKeyPathDropLast<K extends any, T extends any>(this_: KeyPath<K, Array<T>>): Modification<K>;
export declare function xKeyPathDropFirst<K extends any, T extends any>(this_: KeyPath<K, Array<T>>): Modification<K>;
export declare function xKeyPathMap<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, modification: ((a: KeyPath<T, T>) => Modification<T>)): Modification<K>;
export declare function xKeyPathMapIf<K extends any, T extends any>(this_: KeyPath<K, Array<T>>, condition: ((a: KeyPath<T, T>) => Condition<T>), modification: ((a: KeyPath<T, T>) => Modification<T>)): Modification<K>;
export declare function xKeyPathPlusMap<K extends any, T extends any>(this_: KeyPath<K, Map<string, T>>, map: Map<string, T>): Modification<K>;
export declare function xKeyPathModifyByKey<K extends any, T extends any>(this_: KeyPath<K, Map<string, T>>, map: Map<string, ((a: KeyPath<T, T>) => Modification<T>)>): Modification<K>;
export declare function xKeyPathRemoveKeys<K extends any, T extends any>(this_: KeyPath<K, Map<string, T>>, fields: Set<string>): Modification<K>;
