import { Condition } from './Condition';
import { DataClassPath } from './DataClassPath';
import { Modification } from './Modification';
export declare class CMBuilder<From extends any, To extends any> {
    readonly mapCondition: ((a: Condition<To>) => Condition<From>);
    readonly mapModification: ((a: Modification<To>) => Modification<From>);
    constructor(mapCondition: ((a: Condition<To>) => Condition<From>), mapModification: ((a: Modification<To>) => Modification<From>));
}
export declare function xDataClassPathToCMBuilder<From extends any, To extends any>(this_: DataClassPath<From, To>): CMBuilder<From, To>;
export declare function path<T extends any>(): DataClassPath<T, T>;
export declare function condition<T extends any>(setup: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<T>;
export declare function xDataClassPathAlwaysGet<K extends any>(this_: DataClassPath<K, K>): Condition<K>;
export declare function xDataClassPathNeverGet<K extends any>(this_: DataClassPath<K, K>): Condition<K>;
export declare function xDataClassPathEq<K extends any, T extends any>(this_: DataClassPath<K, T>, value: T): Condition<K>;
export declare function xDataClassPathNeq<K extends any, T extends any>(this_: DataClassPath<K, T>, value: T): Condition<K>;
export declare function xDataClassPathNe<K extends any, T extends any>(this_: DataClassPath<K, T>, value: T): Condition<K>;
export declare function xDataClassPathInsideSet<K extends any, T extends any>(this_: DataClassPath<K, T>, values: Set<T>): Condition<K>;
export declare function xDataClassPathInside<K extends any, T extends any>(this_: DataClassPath<K, T>, values: Array<T>): Condition<K>;
export declare function xDataClassPathNinSet<K extends any, T extends any>(this_: DataClassPath<K, T>, values: Set<T>): Condition<K>;
export declare function xDataClassPathNin<K extends any, T extends any>(this_: DataClassPath<K, T>, values: Array<T>): Condition<K>;
export declare function xDataClassPathNotInSet<K extends any, T extends any>(this_: DataClassPath<K, T>, values: Set<T>): Condition<K>;
export declare function xDataClassPathNotIn<K extends any, T extends any>(this_: DataClassPath<K, T>, values: Array<T>): Condition<K>;
export declare function xDataClassPathGt<K extends any, T extends any>(this_: DataClassPath<K, T>, value: T): Condition<K>;
export declare function xDataClassPathLt<K extends any, T extends any>(this_: DataClassPath<K, T>, value: T): Condition<K>;
export declare function xDataClassPathGte<K extends any, T extends any>(this_: DataClassPath<K, T>, value: T): Condition<K>;
export declare function xDataClassPathLte<K extends any, T extends any>(this_: DataClassPath<K, T>, value: T): Condition<K>;
export declare function xDataClassPathAllClear<K extends any>(this_: DataClassPath<K, number>, mask: number): Condition<K>;
export declare function xDataClassPathAllSet<K extends any>(this_: DataClassPath<K, number>, mask: number): Condition<K>;
export declare function xDataClassPathAnyClear<K extends any>(this_: DataClassPath<K, number>, mask: number): Condition<K>;
export declare function xDataClassPathAnySet<K extends any>(this_: DataClassPath<K, number>, mask: number): Condition<K>;
export declare function xDataClassPathContains<K extends any>(this_: DataClassPath<K, string>, value: string): Condition<K>;
export declare function xDataClassPathContainsCased<K extends any>(this_: DataClassPath<K, string>, value: string, ignoreCase: boolean): Condition<K>;
export declare function xDataClassPathFullTextSearch<K extends any, V extends any>(this_: DataClassPath<K, V>, value: string, ignoreCase: boolean): Condition<K>;
export declare function xDataClassPathListAll<K extends any, T extends any>(this_: DataClassPath<K, Array<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xDataClassPathListAny<K extends any, T extends any>(this_: DataClassPath<K, Array<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xDataClassPathListSizedEqual<K extends any, T extends any>(this_: DataClassPath<K, Array<T>>, count: number): Condition<K>;
export declare function xDataClassPathSetAll<K extends any, T extends any>(this_: DataClassPath<K, Set<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xDataClassPathSetAny<K extends any, T extends any>(this_: DataClassPath<K, Set<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xDataClassPathSetSizedEqual<K extends any, T extends any>(this_: DataClassPath<K, Set<T>>, count: number): Condition<K>;
export declare function xDataClassPathContainsKey<K extends any, T extends any>(this_: DataClassPath<K, Map<string, T>>, key: string): Condition<K>;
export declare function xDataClassPathCondition<K extends any, T extends any>(this_: DataClassPath<K, T>, make: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xCMBuilderAlwaysGet<K extends any>(this_: CMBuilder<K, K>): Condition<K>;
export declare function xCMBuilderNeverGet<K extends any>(this_: CMBuilder<K, K>): Condition<K>;
export declare function xCMBuilderEq<K extends any, T extends any>(this_: CMBuilder<K, T>, value: T): Condition<K>;
export declare function xCMBuilderNeq<K extends any, T extends any>(this_: CMBuilder<K, T>, value: T): Condition<K>;
export declare function xCMBuilderNe<K extends any, T extends any>(this_: CMBuilder<K, T>, value: T): Condition<K>;
export declare function xCMBuilderInsideSet<K extends any, T extends any>(this_: CMBuilder<K, T>, values: Set<T>): Condition<K>;
export declare function xCMBuilderInside<K extends any, T extends any>(this_: CMBuilder<K, T>, values: Array<T>): Condition<K>;
export declare function xCMBuilderNinSet<K extends any, T extends any>(this_: CMBuilder<K, T>, values: Set<T>): Condition<K>;
export declare function xCMBuilderNin<K extends any, T extends any>(this_: CMBuilder<K, T>, values: Array<T>): Condition<K>;
export declare function xCMBuilderNotInSet<K extends any, T extends any>(this_: CMBuilder<K, T>, values: Set<T>): Condition<K>;
export declare function xCMBuilderNotIn<K extends any, T extends any>(this_: CMBuilder<K, T>, values: Array<T>): Condition<K>;
export declare function xCMBuilderGt<K extends any, T extends any>(this_: CMBuilder<K, T>, value: T): Condition<K>;
export declare function xCMBuilderLt<K extends any, T extends any>(this_: CMBuilder<K, T>, value: T): Condition<K>;
export declare function xCMBuilderGte<K extends any, T extends any>(this_: CMBuilder<K, T>, value: T): Condition<K>;
export declare function xCMBuilderLte<K extends any, T extends any>(this_: CMBuilder<K, T>, value: T): Condition<K>;
export declare function xCMBuilderAllClear<K extends any>(this_: CMBuilder<K, number>, mask: number): Condition<K>;
export declare function xCMBuilderAllSet<K extends any>(this_: CMBuilder<K, number>, mask: number): Condition<K>;
export declare function xCMBuilderAnyClear<K extends any>(this_: CMBuilder<K, number>, mask: number): Condition<K>;
export declare function xCMBuilderAnySet<K extends any>(this_: CMBuilder<K, number>, mask: number): Condition<K>;
export declare function xCMBuilderContains<K extends any>(this_: CMBuilder<K, string>, value: string): Condition<K>;
export declare function xCMBuilderContainsCased<K extends any>(this_: CMBuilder<K, string>, value: string, ignoreCase: boolean): Condition<K>;
export declare function xCMBuilderFullTextSearch<K extends any, V extends any>(this_: CMBuilder<K, V>, value: string, ignoreCase: boolean): Condition<K>;
export declare function xCMBuilderListAll<K extends any, T extends any>(this_: CMBuilder<K, Array<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xCMBuilderListAny<K extends any, T extends any>(this_: CMBuilder<K, Array<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xCMBuilderListSizedEqual<K extends any, T extends any>(this_: CMBuilder<K, Array<T>>, count: number): Condition<K>;
export declare function xCMBuilderSetAll<K extends any, T extends any>(this_: CMBuilder<K, Set<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xCMBuilderSetAny<K extends any, T extends any>(this_: CMBuilder<K, Set<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xCMBuilderSetSizedEqual<K extends any, T extends any>(this_: CMBuilder<K, Set<T>>, count: number): Condition<K>;
export declare function xCMBuilderContainsKey<K extends any, T extends any>(this_: CMBuilder<K, Map<string, T>>, key: string): Condition<K>;
export declare function xCMBuilderCondition<K extends any, T extends any>(this_: CMBuilder<K, T>, make: ((a: DataClassPath<T, T>) => Condition<T>)): Condition<K>;
export declare function xCMBuilderNotNullGet<K extends any, T extends any>(this_: CMBuilder<K, (T | null)>): CMBuilder<K, T>;
export declare function xCMBuilderGet<K extends any, T extends any>(this_: CMBuilder<K, Map<string, T>>, key: string): CMBuilder<K, T>;
export declare function xCMBuilderListAllGet<K extends any, T extends any>(this_: CMBuilder<K, Array<T>>): CMBuilder<K, T>;
export declare function xCMBuilderSetAllGet<K extends any, T extends any>(this_: CMBuilder<K, Set<T>>): CMBuilder<K, T>;
export declare function xCMBuilderListAnyGet<K extends any, T extends any>(this_: CMBuilder<K, Array<T>>): CMBuilder<K, T>;
export declare function xCMBuilderSetAnyGet<K extends any, T extends any>(this_: CMBuilder<K, Set<T>>): CMBuilder<K, T>;
export declare function xUnitThen(this_: void, ignored: void): void;
