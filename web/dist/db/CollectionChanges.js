"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xCollectionChangesMap = exports.xListApply = exports.CollectionChanges = void 0;
// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
const EntryChange_1 = require("./EntryChange");
const khrysalis_runtime_1 = require("@lightningkite/khrysalis-runtime");
//! Declares com.lightningkite.lightningdb.CollectionChanges
class CollectionChanges {
    constructor(changes = []) {
        this.changes = changes;
    }
    static propertyTypes(T) {
        return { changes: [Array, [EntryChange_1.EntryChange, T]] };
    }
    static pair(old = null, _new = null) {
        let result = new CollectionChanges(old !== null || _new !== null ? [new EntryChange_1.EntryChange(old, _new)] : []);
        return result;
    }
}
exports.CollectionChanges = CollectionChanges;
CollectionChanges.properties = ["changes"];
(0, khrysalis_runtime_1.setUpDataClass)(CollectionChanges);
//! Declares com.lightningkite.lightningdb.apply>kotlin.collections.Listcom.lightningkite.lightningdb.apply.T
function xListApply(this_, changes) {
    const changeable = Array.from(this_);
    for (const change of changes.changes) {
        const old_0 = change.old;
        if (old_0 !== null) {
            (0, khrysalis_runtime_1.listRemoveAll)(changeable, (it) => ((0, khrysalis_runtime_1.safeEq)(it._id, old_0._id)));
        }
        const new_2 = change._new;
        if (new_2 !== null) {
            changeable.push(new_2);
        }
    }
    return changeable;
}
exports.xListApply = xListApply;
//! Declares com.lightningkite.lightningdb.map>com.lightningkite.lightningdb.CollectionChangescom.lightningkite.lightningdb.map.T
function xCollectionChangesMap(this_, mapper) {
    return new CollectionChanges(this_.changes.map((it) => ((0, EntryChange_1.xEntryChangeMap)(it, mapper))));
}
exports.xCollectionChangesMap = xCollectionChangesMap;
//# sourceMappingURL=CollectionChanges.js.map