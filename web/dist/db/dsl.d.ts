import { Condition } from './Condition';
import { Modification } from './Modification';
import { Comparable, TProperty1 } from '@lightningkite/khrysalis-runtime';
export declare function startChain<T extends any>(): PropChain<T, T>;
export declare class PropChain<From extends any, To extends any> {
    readonly mapCondition: ((a: Condition<To>) => Condition<From>);
    readonly mapModification: ((a: Modification<To>) => Modification<From>);
    constructor(mapCondition: ((a: Condition<To>) => Condition<From>), mapModification: ((a: Modification<To>) => Modification<From>));
    get<V extends any>(prop: TProperty1<To, V>): PropChain<From, V>;
    toString(): string;
}
export declare function condition<T extends any>(setup: ((a: PropChain<T, T>) => Condition<T>)): Condition<T>;
export declare function modification<T extends any>(setup: ((a: PropChain<T, T>) => Modification<T>)): Modification<T>;
export declare function xPropChainAlwaysGet<K extends any>(this_: PropChain<K, K>): Condition<K>;
export declare function xPropChainNeverGet<K extends any>(this_: PropChain<K, K>): Condition<K>;
export declare function xPropChainEq<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Condition<K>;
export declare function xPropChainNeq<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Condition<K>;
export declare function xPropChainNe<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Condition<K>;
export declare function xPropChainInside<K extends any, T extends any>(this_: PropChain<K, T>, values: Array<T>): Condition<K>;
export declare function xPropChainNin<K extends any, T extends any>(this_: PropChain<K, T>, values: Array<T>): Condition<K>;
export declare function xPropChainNotIn<K extends any, T extends any>(this_: PropChain<K, T>, values: Array<T>): Condition<K>;
export declare function xPropChainGt<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Condition<K>;
export declare function xPropChainLt<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Condition<K>;
export declare function xPropChainGte<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Condition<K>;
export declare function xPropChainLte<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Condition<K>;
export declare function xPropChainAllClear<K extends any>(this_: PropChain<K, number>, mask: number): Condition<K>;
export declare function xPropChainAllSet<K extends any>(this_: PropChain<K, number>, mask: number): Condition<K>;
export declare function xPropChainAnyClear<K extends any>(this_: PropChain<K, number>, mask: number): Condition<K>;
export declare function xPropChainAnySet<K extends any>(this_: PropChain<K, number>, mask: number): Condition<K>;
export declare function xPropChainContains<K extends any>(this_: PropChain<K, string>, value: string): Condition<K>;
export declare function xPropChainContainsCased<K extends any>(this_: PropChain<K, string>, value: string, ignoreCase: boolean): Condition<K>;
export declare function xPropChainFullTextSearch<K extends any, V extends any>(this_: PropChain<K, V>, value: string, ignoreCase: boolean): Condition<K>;
export declare function xPropChainListAll<K extends any, T extends any>(this_: PropChain<K, Array<T>>, condition: ((a: PropChain<T, T>) => Condition<T>)): Condition<K>;
export declare function xPropChainListAny<K extends any, T extends any>(this_: PropChain<K, Array<T>>, condition: ((a: PropChain<T, T>) => Condition<T>)): Condition<K>;
export declare function xPropChainListSizedEqual<K extends any, T extends any>(this_: PropChain<K, Array<T>>, count: number): Condition<K>;
export declare function xPropChainSetAll<K extends any, T extends any>(this_: PropChain<K, Set<T>>, condition: ((a: PropChain<T, T>) => Condition<T>)): Condition<K>;
export declare function xPropChainSetAny<K extends any, T extends any>(this_: PropChain<K, Set<T>>, condition: ((a: PropChain<T, T>) => Condition<T>)): Condition<K>;
export declare function xPropChainSetSizedEqual<K extends any, T extends any>(this_: PropChain<K, Set<T>>, count: number): Condition<K>;
export declare function xPropChainContainsKey<K extends any, T extends any>(this_: PropChain<K, Map<string, T>>, key: string): Condition<K>;
export declare function xPropChainNotNullGet<K extends any, T extends any>(this_: PropChain<K, (T | null)>): PropChain<K, T>;
export declare function xPropChainGet<K extends any, T extends any>(this_: PropChain<K, Map<string, T>>, key: string): PropChain<K, T>;
export declare function xPropChainCondition<K extends any, T extends any>(this_: PropChain<K, T>, make: ((a: PropChain<T, T>) => Condition<T>)): Condition<K>;
export declare function xPropChainModification<K extends any, T extends any>(this_: PropChain<K, T>, make: ((a: PropChain<T, T>) => Modification<T>)): Modification<K>;
export declare function xPropChainAssign<K extends any, T extends any>(this_: PropChain<K, T>, value: T): Modification<K>;
export declare function xPropChainCoerceAtMost<K extends any, T extends Comparable<T>>(this_: PropChain<K, T>, value: T): Modification<K>;
export declare function xPropChainCoerceAtLeast<K extends any, T extends Comparable<T>>(this_: PropChain<K, T>, value: T): Modification<K>;
export declare function xPropChainPlusNumber<K extends any, T extends number>(this_: PropChain<K, T>, by: T): Modification<K>;
export declare function xPropChainTimes<K extends any, T extends number>(this_: PropChain<K, T>, by: T): Modification<K>;
export declare function xPropChainPlusString<K extends any>(this_: PropChain<K, string>, value: string): Modification<K>;
export declare function xPropChainPlusItemsList<K extends any, T>(this_: PropChain<K, Array<T>>, items: Array<T>): Modification<K>;
export declare function xPropChainPlusItemsSet<K extends any, T>(this_: PropChain<K, Set<T>>, items: Set<T>): Modification<K>;
export declare function xPropChainPlusItemList<K extends any, T>(this_: PropChain<K, Array<T>>, item: T): Modification<K>;
export declare function xPropChainPlusItemSet<K extends any, T>(this_: PropChain<K, Set<T>>, item: T): Modification<K>;
export declare function xPropChainListAddAll<K extends any, T extends any>(this_: PropChain<K, Array<T>>, items: Array<T>): Modification<K>;
export declare function xPropChainSetAddAll<K extends any, T extends any>(this_: PropChain<K, Set<T>>, items: Set<T>): Modification<K>;
export declare function xPropChainListRemove<K extends any, T extends any>(this_: PropChain<K, Array<T>>, condition: ((a: PropChain<T, T>) => Condition<T>)): Modification<K>;
export declare function xPropChainSetRemove<K extends any, T extends any>(this_: PropChain<K, Set<T>>, condition: ((a: PropChain<T, T>) => Condition<T>)): Modification<K>;
export declare function xPropChainListRemoveAll<K extends any, T extends any>(this_: PropChain<K, Array<T>>, items: Array<T>): Modification<K>;
export declare function xPropChainSetRemoveAll<K extends any, T extends any>(this_: PropChain<K, Set<T>>, items: Set<T>): Modification<K>;
export declare function xPropChainListDropLast<K extends any, T extends any>(this_: PropChain<K, Array<T>>): Modification<K>;
export declare function xPropChainSetDropLast<K extends any, T extends any>(this_: PropChain<K, Set<T>>): Modification<K>;
export declare function xPropChainListDropFirst<K extends any, T extends any>(this_: PropChain<K, Array<T>>): Modification<K>;
export declare function xPropChainSetDropFirst<K extends any, T extends any>(this_: PropChain<K, Set<T>>): Modification<K>;
export declare function xPropChainListMap<K extends any, T extends any>(this_: PropChain<K, Array<T>>, modification: ((a: PropChain<T, T>) => Modification<T>)): Modification<K>;
export declare function xPropChainSetMap<K extends any, T extends any>(this_: PropChain<K, Set<T>>, modification: ((a: PropChain<T, T>) => Modification<T>)): Modification<K>;
export declare function xPropChainListMapIf<K extends any, T extends any>(this_: PropChain<K, Array<T>>, condition: ((a: PropChain<T, T>) => Condition<T>), modification: ((a: PropChain<T, T>) => Modification<T>)): Modification<K>;
export declare function xPropChainSetMapIf<K extends any, T extends any>(this_: PropChain<K, Set<T>>, condition: ((a: PropChain<T, T>) => Condition<T>), modification: ((a: PropChain<T, T>) => Modification<T>)): Modification<K>;
export declare function xPropChainPlusMap<K extends any, T extends any>(this_: PropChain<K, Map<string, T>>, map: Map<string, T>): Modification<K>;
export declare function xPropChainModifyByKey<K extends any, T extends any>(this_: PropChain<K, Map<string, T>>, map: Map<string, ((a: PropChain<T, T>) => Modification<T>)>): Modification<K>;
export declare function xPropChainRemoveKeys<K extends any, T extends any>(this_: PropChain<K, Map<string, T>>, fields: Set<string>): Modification<K>;
