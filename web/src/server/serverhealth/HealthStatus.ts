// Package: com.lightningkite.lightningserver.serverhealth
// Generated by Khrysalis - this file will be overwritten.
import { Instant } from '@js-joda/core'
import { ReifiedType, parseObject, setUpDataClass } from '@lightningkite/khrysalis-runtime'

//! Declares com.lightningkite.lightningserver.serverhealth.HealthStatus
export class HealthStatus {
    public constructor(public readonly level: HealthStatus.Level, public readonly checkedAt: Instant = Instant.now(), public readonly additionalMessage: (string | null) = null) {
    }
    public static properties = ["level", "checkedAt", "additionalMessage"]
    public static propertyTypes() { return {level: [HealthStatus.Level], checkedAt: [Instant], additionalMessage: [String]} }
    copy: (values: Partial<HealthStatus>) => this;
    equals: (other: any) => boolean;
    hashCode: () => number;
    
    
}
setUpDataClass(HealthStatus)
export namespace HealthStatus {
    //! Declares com.lightningkite.lightningserver.serverhealth.HealthStatus.Level
    export class Level {
        private constructor(name: string, jsonName: string, public readonly color: string) {
            this.name = name;
            this.jsonName = jsonName;
        }
        
        public static OK = new Level("OK", "OK", "green");
        
        public static WARNING = new Level("WARNING", "WARNING", "yellow");
        
        public static URGENT = new Level("URGENT", "URGENT", "orange");
        
        public static ERROR = new Level("ERROR", "ERROR", "red");
        
        private static _values: Array<Level> = [Level.OK, Level.WARNING, Level.URGENT, Level.ERROR];
        public static values(): Array<Level> { return Level._values; }
        public readonly name: string;
        public readonly jsonName: string;
        public static valueOf(name: string): Level { return (Level as any)[name]; }
        public toString(): string { return this.name }
        public toJSON(): string { return this.jsonName }
        public static fromJSON(key: string): Level { return Level._values.find(x => x.jsonName.toLowerCase() === key.toLowerCase())! }
    }
}

//! Declares com.lightningkite.lightningserver.serverhealth.ServerHealth
export class ServerHealth {
    public constructor(public readonly serverId: string, public readonly version: string, public readonly memory: ServerHealth.Memory, public readonly features: Map<string, HealthStatus>, public readonly loadAverageCpu: number) {
    }
    public static properties = ["serverId", "version", "memory", "features", "loadAverageCpu"]
    public static propertyTypes() { return {serverId: [String], version: [String], memory: [ServerHealth.Memory], features: [Map, [String], [HealthStatus]], loadAverageCpu: [Number]} }
    copy: (values: Partial<ServerHealth>) => this;
    equals: (other: any) => boolean;
    hashCode: () => number;
    
    
    
}
setUpDataClass(ServerHealth)
export namespace ServerHealth {
    //! Declares com.lightningkite.lightningserver.serverhealth.ServerHealth.Memory
    export class Memory {
        public constructor(public readonly maxMem: number, public readonly totalMemory: number, public readonly freeMemory: number, public readonly systemAllocated: number, public readonly memUsagePercent: number) {
        }
        public static properties = ["maxMem", "totalMemory", "freeMemory", "systemAllocated", "memUsagePercent"]
        public static propertyTypes() { return {maxMem: [Number], totalMemory: [Number], freeMemory: [Number], systemAllocated: [Number], memUsagePercent: [Number]} }
        copy: (values: Partial<Memory>) => this;
        equals: (other: any) => boolean;
        hashCode: () => number;
        
    }
    setUpDataClass(Memory)
}