// Package: com.lightningkite.lightningdb.live
// Generated by Khrysalis - this file will be overwritten.
import { MultiplexMessage } from '../db/MultiplexMessage'
import { ReifiedType, runOrNull, xMutableMapGetOrPut, xStringSubstringBefore } from '@lightningkite/khrysalis-runtime'
import { HttpClient, JSON2, WebSocketFrame, WebSocketInterface, doOnSubscribe, isNonNull } from '@lightningkite/rxjs-plus'
import { NEVER, Observable, SubscriptionLike, filter, interval, merge, of, map as rMap } from 'rxjs'
import { map, filter as oFilter, publishReplay, refCount, switchMap, take, tap, timeout } from 'rxjs/operators'
import { v4 as randomUuidV4 } from 'uuid'

//! Declares com.lightningkite.lightningdb.live._overrideWebSocketProvider
export let __overrideWebSocketProvider: (((url: string) => Observable<WebSocketInterface>) | null) = null;
export function get_overrideWebSocketProvider(): (((url: string) => Observable<WebSocketInterface>) | null) { return __overrideWebSocketProvider; }
export function set_overrideWebSocketProvider(value: (((url: string) => Observable<WebSocketInterface>) | null)) { __overrideWebSocketProvider = value; }
const sharedSocketCache = new Map<string, Observable<WebSocketInterface>>();
//! Declares com.lightningkite.lightningdb.live.sharedSocket
export function sharedSocket(url: string): Observable<WebSocketInterface> {
    return xMutableMapGetOrPut<string, Observable<WebSocketInterface>>(sharedSocketCache, url, (): Observable<WebSocketInterface> => {
        const shortUrl = xStringSubstringBefore(url, '?', undefined);
        //        println("Creating socket to $url")
        return (runOrNull(get_overrideWebSocketProvider(), _ => _(url)) ?? HttpClient.INSTANCE.webSocket(url))
            .pipe(switchMap((it: WebSocketInterface): Observable<WebSocketInterface> => {
            //                println("Connection to $shortUrl established, starting pings")
            // Only have this observable until it fails
            
            const pingMessages: Observable<WebSocketInterface> = interval(30000).pipe(map((_0: number): void => {
                //                    println("Sending ping to $url")
                return it.write.next({ text: " ", binary: null });
            })).pipe(switchMap((it: void): Observable<WebSocketInterface> => (NEVER)));
            
            const timeoutAfterSeconds: Observable<WebSocketInterface> = it.read
                .pipe(timeout(60000))
                .pipe(switchMap((it: WebSocketFrame): Observable<WebSocketInterface> => (NEVER)));
            
            return merge(of(it), pingMessages, timeoutAfterSeconds);
        }))
            .pipe(tap(undefined, (it: any): void => {
            console.log(`Socket to ${shortUrl} FAILED with ${it}`);
        }))
            .pipe(tap(undefined, undefined, (): void => {
            //                println("Disconnecting socket to $shortUrl")
            sharedSocketCache.delete(url);
        }))
            .pipe(publishReplay(1))
            .pipe(refCount());
    });
}

//! Declares com.lightningkite.lightningdb.live.WebSocketIsh
export class WebSocketIsh<IN extends any, OUT extends any> {
    public constructor(public readonly messages: Observable<IN>, public readonly send: ((a: OUT) => void)) {
    }
}

//! Declares com.lightningkite.lightningdb.live.multiplexedSocket
export function multiplexedSocketReified<IN extends any, OUT extends any>(IN: Array<any>, OUT: Array<any>, url: string, path: string, queryParams: Map<string, Array<string>> = new Map([])): Observable<WebSocketIsh<IN, OUT>> {
    return multiplexedSocket<IN, OUT>(url, path, queryParams, IN, OUT);
}

//! Declares com.lightningkite.lightningdb.live.multiplexedSocket
export function multiplexedSocket<IN extends any, OUT extends any>(url: string, path: string, queryParams: Map<string, Array<string>> = new Map([]), inType: ReifiedType, outType: ReifiedType): Observable<WebSocketIsh<IN, OUT>> {
    return multiplexedSocketRaw(url, path, queryParams)
        .pipe(map((it: WebSocketIsh<string, string>): WebSocketIsh<IN, OUT> => (new WebSocketIsh<IN, OUT>(it.messages.pipe(rMap((it: string): (IN | null) => (JSON2.parse<IN>(it, inType))), filter(isNonNull)), (m: OUT): void => {
        it.send(JSON.stringify(m));
    }))));
}
//! Declares com.lightningkite.lightningdb.live.multiplexedSocketRaw
export function multiplexedSocketRaw(url: string, path: string, queryParams: Map<string, Array<string>> = new Map([])): Observable<WebSocketIsh<string, string>> {
    const shortUrl = xStringSubstringBefore(url, '?', undefined);
    const channel = randomUuidV4();
    let lastSocket: (WebSocketInterface | null) = null;
    return sharedSocket(url)
        .pipe(switchMap((it: WebSocketInterface): Observable<WebSocketIsh<string, string>> => {
        //            println("Setting up socket to $shortUrl with $path")
        lastSocket = it;
        //            println("Connected to $it")
        const multiplexedIn = it.read.pipe(rMap((it: WebSocketFrame): (MultiplexMessage | null) => {
            //                    println("Got raw from websocket $it")
            const text = it.text
            if(text === null) { return null }
            if (text === "") { return null }
            return JSON2.parse<MultiplexMessage>(text, [MultiplexMessage]);
        }), filter(isNonNull));
        return multiplexedIn
            .pipe(oFilter((it: MultiplexMessage): boolean => (it.channel === channel && it.start)))
            .pipe(take(1))
            .pipe(map((_0: MultiplexMessage): WebSocketIsh<string, string> => (new WebSocketIsh<string, string>(multiplexedIn.pipe(rMap((it: MultiplexMessage): (string | null) => (it.channel === channel ? it.data : null)), filter(isNonNull)), (message: string): void => {
            //                    println("Sending $message to $it")
            it.write.next({ text: JSON.stringify(new MultiplexMessage(channel, undefined, undefined, undefined, undefined, message, undefined)), binary: null });
        }))))
            .pipe(doOnSubscribe((_0: SubscriptionLike): void => {
            it.write.next({ text: JSON.stringify(new MultiplexMessage(channel, path, queryParams, true, undefined, undefined, undefined)), binary: null });
        }));
    }))
        .pipe(tap({ unsubscribe: (): void => {
        //            println("Disconnecting channel on socket to $shortUrl with $path")
        const temp49 = (lastSocket?.write ?? null);
        if (temp49 !== null && temp49 !== undefined) {
            temp49.next({ text: JSON.stringify(new MultiplexMessage(channel, path, undefined, undefined, true, undefined, undefined)), binary: null })
        };
    } }));
}
