// Package: com.lightningkite.lightningdb.mock
// Generated by Khrysalis - this file will be overwritten.
import { WriteModelApi } from '../WriteModelApi'
import { Condition } from '../db/Condition'
import { HasId } from '../db/HasId'
import { MassModification } from '../db/MassModification'
import { Modification } from '../db/Modification'
import { UUIDFor } from '../db/UUIDFor'
import { ItemNotFound } from './ItemNotFound'
import { MockTable } from './MockTable'
import { forEach } from 'iter-tools-es'
import { Observable, of, throwError } from 'rxjs'
import { map } from 'rxjs/operators'

//! Declares com.lightningkite.lightningdb.mock.MockWriteModelApi
export class MockWriteModelApi<Model extends HasId<string>> extends WriteModelApi<Model> {
    public constructor(public readonly table: MockTable<Model>) {
        super();
    }
    
    
    public post(value: Model): Observable<Model> {
        return of(this.table.addItem(value));
    }
    
    public postBulk(values: Array<Model>): Observable<Array<Model>> {
        return of(values.map((it: Model): Model => (this.table.addItem(it))));
    }
    
    public put(value: Model): Observable<Model> {
        return of(this.table.replaceItem(value));
    }
    
    public putBulk(values: Array<Model>): Observable<Array<Model>> {
        return of(values.map((it: Model): Model => (this.table.replaceItem(it))));
    }
    
    public patch(id: UUIDFor<Model>, modification: Modification<Model>): Observable<Model> {
        return ((): (Observable<Model> | null) => {
            const temp6 = (this.table.data.get(id) ?? null);
            if (temp6 === null || temp6 === undefined) { return null }
            return ((item: Model): Observable<Model> => {
                const modified = modification.invoke(item);
                this.table.replaceItem(modified);
                return of(modified);
            })(temp6)
        })() ?? throwError(new ItemNotFound(`404 item with key ${id} not found`));
    }
    
    public patchBulk(modification: MassModification<Model>): Observable<number> {
        return of(this.table
                .asList()
                .filter((it: Model): boolean => (modification.condition.invoke(it)))
            .map((it: Model): Model => (this.table.replaceItem(modification.modification.invoke(it)))))
            .pipe(map((it: Array<Model>): number => (it.length)));
    }
    
    public _delete(id: UUIDFor<Model>): Observable<void> {
        return of(this.table.deleteItemById(id));
    }
    
    public deleteBulk(condition: Condition<Model>): Observable<void> {
        return of(this.table
                .asList()
                .filter((it: Model): boolean => (condition.invoke(it)))
                .forEach((it: Model): void => {
                this.table.deleteItem(it);
        }));
    }
}