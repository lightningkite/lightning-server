// Package: com.lightningkite.lightningdb
// Generated by Khrysalis - this file will be overwritten.
import { Condition } from './Condition'
import { path } from './ConditionBuilder'
import { DataClassPath } from './DataClassPath'
import { Modification } from './Modification'
import { Comparable, EqualOverrideSet, also } from '@lightningkite/khrysalis-runtime'
import { map } from 'iter-tools-es'

//! Declares com.lightningkite.lightningdb.modification
export function modification<T extends any>(setup: ((a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void)): Modification<T> {
    return also(new ModificationBuilder<T>(), (this_: ModificationBuilder<T>): void => {
        setup(this_, path<T>());
    }).build();
}

//! Declares com.lightningkite.lightningdb.and>com.lightningkite.lightningdb.Modificationcom.lightningkite.lightningdb.and.T
export function xModificationAnd<T extends any>(this_: Modification<T>, setup: ((a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void)): Modification<T> {
    return also(new ModificationBuilder<T>(), (this_1: ModificationBuilder<T>): void => {
        this_1.modifications.push(this_);
        setup(this_1, path<T>());
    }).build();
}

//! Declares com.lightningkite.lightningdb.ModificationBuilder
export class ModificationBuilder<K extends any> {
    public constructor() {
        this.modifications = ([] as Array<Modification<K>>);
    }
    
    public readonly modifications: Array<Modification<K>>;
    public add(modification: Modification<K>): void { this.modifications.push(modification); }
    public build(): Modification<K> {
        if (this.modifications.length === 1) { return this.modifications[0] } else { return new Modification.Chain<K>(this.modifications) }
    }
    
    public assign<T extends any>(this_: DataClassPath<K, T>, value: T): void {
        this.modifications.push(this_.mapModification(new Modification.Assign<T>(value)));
    }
    
    public coerceAtMost<T extends Comparable<T>>(this_: DataClassPath<K, T>, value: T): void {
        this.modifications.push(this_.mapModification(new Modification.CoerceAtMost<T>(value)));
    }
    
    public coerceAtLeast<T extends Comparable<T>>(this_: DataClassPath<K, T>, value: T): void {
        this.modifications.push(this_.mapModification(new Modification.CoerceAtLeast<T>(value)));
    }
    
    public plusAssignNumber<T extends number>(this_: DataClassPath<K, T>, by: T): void {
        this.modifications.push(this_.mapModification(new Modification.Increment<T>(by)));
    }
    
    public timesAssign<T extends number>(this_: DataClassPath<K, T>, by: T): void {
        this.modifications.push(this_.mapModification(new Modification.Multiply<T>(by)));
    }
    
    public plusAssignString(this_: DataClassPath<K, string>, value: string): void {
        this.modifications.push(this_.mapModification(new Modification.AppendString(value)));
    }
    
    public plusAssignList<T>(this_: DataClassPath<K, Array<T>>, items: Array<T>): void {
        this.modifications.push(this_.mapModification(new Modification.ListAppend<T>(items)));
    }
    
    public plusAssignSet<T>(this_: DataClassPath<K, Set<T>>, items: Set<T>): void {
        this.modifications.push(this_.mapModification(new Modification.SetAppend<T>(items)));
    }
    
    public plusAssignItemList<T>(this_: DataClassPath<K, Array<T>>, item: T): void {
        this.modifications.push(this_.mapModification(new Modification.ListAppend<T>([item])));
    }
    
    public plusAssignItemSet<T>(this_: DataClassPath<K, Set<T>>, item: T): void {
        this.modifications.push(this_.mapModification(new Modification.SetAppend<T>(new EqualOverrideSet([item]))));
    }
    
    public plusAssignListAddAll<T extends any>(this_: DataClassPath<K, Array<T>>, items: Array<T>): void {
        this.modifications.push(this_.mapModification(new Modification.ListAppend<T>(items)));
    }
    
    public plusAssignSetAddAll<T extends any>(this_: DataClassPath<K, Set<T>>, items: Set<T>): void {
        this.modifications.push(this_.mapModification(new Modification.SetAppend<T>(items)));
    }
    
    public removeAllList<T extends any>(this_: DataClassPath<K, Array<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): void {
        this.modifications.push(this_.mapModification(new Modification.ListRemove<T>((condition)(path<T>()))));
    }
    
    public removeAllSet<T extends any>(this_: DataClassPath<K, Set<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>)): void {
        this.modifications.push(this_.mapModification(new Modification.SetRemove<T>((condition)(path<T>()))));
    }
    
    public removeAllItemsList<T extends any>(this_: DataClassPath<K, Array<T>>, items: Array<T>): void {
        this.modifications.push(this_.mapModification(new Modification.ListRemoveInstances<T>(items)));
    }
    
    public removeAllItemsSet<T extends any>(this_: DataClassPath<K, Set<T>>, items: Set<T>): void {
        this.modifications.push(this_.mapModification(new Modification.SetRemoveInstances<T>(items)));
    }
    
    public dropLastList<T extends any>(this_: DataClassPath<K, Array<T>>): void {
        this.modifications.push(this_.mapModification(new Modification.ListDropLast<T>()));
    }
    
    public dropLastSet<T extends any>(this_: DataClassPath<K, Set<T>>): void {
        this.modifications.push(this_.mapModification(new Modification.SetDropLast<T>()));
    }
    
    public dropFirstList<T extends any>(this_: DataClassPath<K, Array<T>>): void {
        this.modifications.push(this_.mapModification(new Modification.ListDropFirst<T>()));
    }
    
    public dropFirstSet<T extends any>(this_: DataClassPath<K, Set<T>>): void {
        this.modifications.push(this_.mapModification(new Modification.SetDropFirst<T>()));
    }
    
    public forEachList<T extends any>(this_: DataClassPath<K, Array<T>>, modification: ((a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void)): void {
        const builder = new ModificationBuilder<T>();
        modification(builder, path<T>());
        this.modifications.push(this_.mapModification(new Modification.ListPerElement<T>(new Condition.Always<T>(), builder.build())));
    }
    
    public forEachSet<T extends any>(this_: DataClassPath<K, Set<T>>, modification: ((a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void)): void {
        const builder = new ModificationBuilder<T>();
        modification(builder, path<T>());
        this.modifications.push(this_.mapModification(new Modification.SetPerElement<T>(new Condition.Always<T>(), builder.build())));
    }
    
    public forEachIfList<T extends any>(this_: DataClassPath<K, Array<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>), modification: ((a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void)): void {
        const builder = new ModificationBuilder<T>();
        modification(builder, path<T>());
        this.modifications.push(this_.mapModification(new Modification.ListPerElement<T>((condition)(path<T>()), builder.build())));
    }
    
    public forEachIfSet<T extends any>(this_: DataClassPath<K, Set<T>>, condition: ((a: DataClassPath<T, T>) => Condition<T>), modification: ((a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void)): void {
        const builder = new ModificationBuilder<T>();
        modification(builder, path<T>());
        this.modifications.push(this_.mapModification(new Modification.SetPerElement<T>((condition)(path<T>()), builder.build())));
    }
    
    public plusAssignMap<T extends any>(this_: DataClassPath<K, Map<string, T>>, map: Map<string, T>): void {
        this.modifications.push(this_.mapModification(new Modification.Combine<T>(map)));
    }
    
    public modifyByKey<T extends any>(this_: DataClassPath<K, Map<string, T>>, byKey: Map<string, ((a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void)>): void {
        this.modifications.push(this_.mapModification(new Modification.ModifyByKey<T>(new Map(map(x => [x[0], ((it: [string, (a: ModificationBuilder<T>, b: DataClassPath<T, T>) => void]): Modification<T> => (modification<T>(it[1])))(x)], byKey.entries())))));
    }
    
    public removeKeys<T extends any>(this_: DataClassPath<K, Map<string, T>>, fields: Set<string>): void {
        this.modifications.push(this_.mapModification(new Modification.RemoveKeys<T>(fields)));
    }
}